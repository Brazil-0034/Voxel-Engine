<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		* {
			margin: 0;
			overflow: hidden;
			font-family: 'Montserrat', sans-serif;
			user-select: none;
		}

		body {
			background: black;
		}

		canvas {
			position: absolute;
			top: 0%;
			left: 0%;
			display: block;
		}

		#crosshair-overlay {
			position: absolute;
			top: 50%;
			left: 50%;
			color: lightgreen;
			text-shadow: 0 0 10px white;
			font-size: 150%;
			z-index: 1000;
			transform: translate(-50%, -50%);
		}

		#position-overlay {
			position: absolute;
			top: 0;
			left: 0;
			color: black;
			text-shadow: 0 0 10px white;
			font-size: 150%;
			z-index: 1000;
			padding: 10px;
		}

		#help-text {
			/* bottom center */
			position: absolute;
			bottom: 0;
			left: 50%;
			color: white;
			text-shadow: 0 0 10px black;
			z-index: 1000;
			padding: 20px;
			transform: translate(-50%, 0);
			opacity: 0.25;
		}

		#loader {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			max-width: 20%
		}

		#loader-bg {
			position: absolute;
			top: 0; left: 0;
			width: 100%;
			height: 100%;
			background: black;
			z-index: 1000;
		}

		@keyframes fade-out {
			0% {
				opacity: 1;
			}
			100% {
				opacity: 0;
			}
		}

		#topbar {
			position: absolute;
			z-index: 1000;
			top: 0;
			right: 0;
			text-align: right;
			width: 100%;
			height: 30px;
			background: #333;
			z-index: 1000;
		}

		.topbar-button {
			display: inline-block;
			color: white;
			font-size: 16px;
			opacity: 0.4;
			cursor: pointer;
		}

		.topbar-button:hover {
			opacity: 1;
		}

		#quit {
            transform: rotate(45deg);
			position: absolute;
			top: 4.5px;
			right: 13.5px;
		}

		#maximize {
			position: absolute;
			top: 5px;
			right: 55px;
			font-size: 14px;
		}

		#minimize {
			position: absolute;
			top: -1px;
			right: 100px;
		}
	</style>

</head>

<body>
	<div id="topbar">
		<span class="topbar-button" id="minimize">&#128469;</span>
		<span class="topbar-button" id="maximize">&#128470;</span>
		<span class="topbar-button" id="quit" onclick="window.close()">&#128929;</span>
	</div>

	<div id="loader-bg">
		<img id="loader" src="img/black_dot.png"/>
	</div>

	<style>
		* {
			margin: 0;
		}
	</style>
	<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
	<script type="importmap">
			{
				"imports": {
					"three": "./threejs/build/three.module.js",
					"three/addons/": "./threejs/examples/jsm/",
					"three/nodes": "./threejs/examples/jsm/nodes/Nodes.js"
				}
			}
	</script>
	<script src="howler/howler.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/tweakpane@3.1.9/dist/tweakpane.min.js"></script>
	<script src="canvasPixelReader.js"></script>
	<div id="middle-crosshair" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 2px; height: 2px; background: white; z-index: 1000;">x</div>
<script type="module">

// choose a loader gif at random
document.querySelector('#loader').src = 'img/loader-' + (Math.floor(Math.random() * 3) + 1) + '.gif'

import * as THREE from 'three';
import { mix, range, normalWorld, oscSine, timerLocal } from 'three/nodes';

// import WebGPU from 'three/addons/capabilities/WebGPU.js';
// import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';

// pointerlock controls
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
// effectcomposer, renderpass, shaderpass
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
// SAO
import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
// FBXLoader
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js'; 

// ipc renderer
const { ipcRenderer } = require('electron');

document.querySelector("#minimize").addEventListener("click", (e) => ipcRenderer.send('minimize'))
document.querySelector("#maximize").addEventListener("click", (e) => ipcRenderer.send('maximizeToggle'))

// This is my JavaScript-based Voxel game (engine)
const USERSETTINGS = {
	debugMode: false,
	useSpriteParticles: true
}

// ###
// DEBUG UI
// ###
const pane = new Tweakpane.Pane();
const paneParent = pane.element.parentElement;
paneParent.style.zIndex = "1000";
paneParent.style.top = "40px";
paneParent.style.opacity = 0;
var positionOverlayValue = new THREE.Vector3();
var frameInfo = { FPS: 0, frameTime: 0, drawCalls: 0 };
// DEBUG UI: FPS
pane.addMonitor(frameInfo, 'FPS', {
	view: 'graph',
	min: 0,
	max: 85 + 1,
	interval: 100
});
pane.addMonitor(frameInfo, 'FPS', {
	view: 'number',
	interval: 60
});
pane.addSeparator();
// DEBUG UI: POSITION
pane.addMonitor(positionOverlayValue, 'x', {
	view: 'text',
	interval: 10
});
pane.addMonitor(positionOverlayValue, 'y', {
	view: 'text',
	interval: 10
});
pane.addMonitor(positionOverlayValue, 'z', {
	view: 'text',
	interval: 10
});
pane.addSeparator();
// DEBUG UI: DRAW CALLS
pane.addMonitor(frameInfo, 'drawCalls', {
	view: 'text',
	interval: 10
});

const lerp = function (a, b, t) {
	return a + (b - a) * t;
}

/**
 * 
 * A VoxelChunk is how WreckMesh renders voxels.
 * It inherits from InstancedMesh with some additional properties for rendering and physics.
 * It is a unified class for all mesh operations in WreckMesh.
 * 
 * @param frustumBox: THREE.Box3 - The bounding box of the chunk, used for frustum culling.
 * @param velocities: THREE.Vector3[] - The velocities of each voxel in the chunk. [Physics Processing Only]
 */
class VoxelChunk extends THREE.InstancedMesh {
	frustumBox
	isActivated
	deadVoxels
	coverBox
	isCovered

	constructor(geometry, material, count) {
		super(geometry, material, count);
		this.frustumBox = new THREE.Box3();
		this.deadVoxels = [];
		this.isCovered = false;
	}

	setCoverBox(coverBox) {
		this.isCovered = true;
		this.coverBox = coverBox;
	}

	uncover() {
		if (this.isCovered == true)
		{
			scene.remove(this.coverBox);
			this.isCovered = false;
			this.visible = true;
		}
	}
}

const VoxelFace = Object.freeze({
	TOP: "top",
	BOTTOM: "bottom",
	LEFT: "left",
	RIGHT: "right",
	FRONT: "front",
	BACK: "back"
});

const SFXVolume = 0.05;
// ##########
// NPC ENGINE
// ##########
// Global File Loaders:
const globalModelLoader = new FBXLoader();
const globalTextureLoader = new THREE.TextureLoader();
const NPCBank = [];
const deathSound = new Howl({
	src: ['sfx/kill_ding.wav'],
	volume: SFXVolume * 7.5
});
// This will be the main system for spawning and handling NPC behavior
class NPC {
	sceneObject // the scene object of the npc - includes the mesh, bones, etc
	npcObject // just the mesh object of the npc (children[0] of sceneObject)
	
	health // health of NPC remaining
	speed // how fast he move -->

	runAnimation // u alr know
	idleAnimation // this too
	mixer // 3js anim mixer (per-npc until instanced skinning makes its way into main branch)

	// This will build the NPC (setting idle/run animation and loading model into scene)
	constructor(npcName, texturePath, position, rotation, speed, health) {
		this.speed = speed;
		this.health = health;
		const basePath = 'character_models/' + npcName + '/';
		globalModelLoader.load(basePath + npcName + '_idle.fbx', object => {
			// STEP 1: ASSIGN MATERIALS
			this.sceneObject = object;
			this.npcObject = object.children[0];
			this.npcObject.npcHandler = this;
			this.sceneObject.traverse(function (childObject) {
				if (childObject.isMesh) {
					childObject.castShadow = true;
					childObject.receiveShadow = true;
					childObject.material = new THREE.MeshPhongMaterial({ 
						map: globalTextureLoader.load(basePath + npcName + '.png'),
						shininess: 0,
						specular: 0x000000
					});
				}
			});

			// STEP 2: ASSIGN TRANSFORMS
			this.sceneObject.position.copy(position);
			this.sceneObject.rotation.set(rotation.x, rotation.y, rotation.z);
			this.sceneObject.scale.multiplyScalar(0.1);

			// STEP 3: APPLY ANIMATIONS
			this.mixer = new THREE.AnimationMixer(this.sceneObject);
			// load run animation
			globalModelLoader.load(basePath + npcName + '_run.fbx', object => {
				this.runAnimation = this.mixer.clipAction(object.animations[0]);
				this.runAnimation.play();
			});
			this.idleAnimation = this.mixer.clipAction(this.sceneObject.animations[0]);
			this.idleAnimation.play();

			// And lastly... add it to the scene!
			if (Math.random() > 0.5) this.sceneObject.scale.x *= -1;
			scene.add(this.sceneObject);

			// add a helper to the bounding sphere
			// compute bounding sphere
			this.npcObject.geometry.computeBoundingSphere();
			this.npcObject.geometry.boundingSphere.set(this.npcObject.position, 512);
		});

		NPCBank.push(this);
	}

	depleteHealth(amount) {
		this.health -= amount;
		if (this.health <= 0) {
			deathSound.rate(clamp(Math.random() + 0.8, 0, 1))
			deathSound.play();
			this.despawn();
		}
	}

	// This will update the NPC's behavior (every frame)
	update(delta) {
		if (!this.sceneObject || !this.mixer || !this.runAnimation || !this.idleAnimation) return;

		// Update the animation mixer keyframe step
		this.mixer.update(delta);

		// Look towards the nearest player (camera) smoothly, using the lerp(a, b, t) function
		const targetRotation = Math.atan2(camera.position.x - this.sceneObject.position.x, camera.position.z - this.sceneObject.position.z);
		// prevent spinning by flipping the rotation value
		if (Math.abs(targetRotation - this.sceneObject.rotation.y) > Math.PI) {
			if (targetRotation > this.sceneObject.rotation.y) {
				this.sceneObject.rotation.y += Math.PI * 2;
			}
			else {
				this.sceneObject.rotation.y -= Math.PI * 2;
			}
		}
		this.sceneObject.rotation.y = lerp(this.sceneObject.rotation.y, targetRotation, delta * 5);

		// lerp the color to 0xffffff
		this.npcObject.material.color.lerp(new THREE.Color(0xffffff), delta * 10);

		// If too far, move closer
		const distanceToCamera = this.sceneObject.position.distanceTo(camera.position);
		if (distanceToCamera > 150) {
			const direction = new THREE.Vector3();
			camera.getWorldDirection(direction);
			direction.y = 0;
			direction.normalize();
			this.sceneObject.position.addScaledVector(direction, -delta * this.speed);
			this.runAnimation.play();
		}
		else
		{
			this.runAnimation.stop();
			this.idleAnimation.play();
		}
	}

	despawn() {
		this.npcObject.material.color = new THREE.Color(0x00ff00);
		this.sceneObject.remove(this.npcObject);
		this.npcObject.geometry.dispose();
		this.npcObject.material.dispose();
	}
}

class ParticleMesh extends THREE.Points {
	velocities
	lifetimes
	lifetime

	constructor(geometry, material) {
		super(geometry, material);
	}
}

// Sets the help text on the bottom center of the player's screen
const setHelpText = (text) => { document.querySelector("#help-text").innerHTML = text }

// SCENE SETUP
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 15, 5000);
// RENDERER SETUP
// Initializes the THREE.js renderer
const renderer = new THREE.WebGLRenderer({
	antialias: true
});
renderer.logarithmicDepthBuffer = true;
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(0x000000);
document.body.appendChild(renderer.domElement);


const composer = new EffectComposer(renderer);
const renderPass = new RenderPass(scene, camera);
composer.addPass(renderPass);

const sao = new SAOPass(scene, camera, true, true);
// THE SCALE of the scene is very very large (thousands of units distance), so we need to scale the SAO pass to match
sao.params.saoScale = 9.5;
sao.params.saoBias = 0.5;
sao.params.saoIntensity = 0.0007;
sao.params.saoKernelRadius = 100;
composer.addPass(sao);

renderer.shadowMap.enabled = true
renderer.shadowMap.type = THREE.PCFSoftShadowMap
renderer.setClearColor(0xffffff)
renderer.toneMappingExposure = 1
renderer.gammaOutput = true
renderer.gammaInput = true
renderer.gammaFactor = 2.2

// const ssaaRenderPass = new SSAARenderPass(scene, camera, 0xAAAAAA, 0)
// composer.addPass(ssaaRenderPass)

// const SAO = new SAOPass(scene, camera, true, true)
// SAO.resolution.set(0.5, 0.5)
// composer.addPass(SAO)

// SAO.params.saoBias = .5
// SAO.params.saoIntensity = .0012
// SAO.params.saoScale = .3
// SAO.params.saoKernelRadius = 40
// SAO.params.saoMinResolution = 0

// What the hell is this?? I fucking hate javascript.
// Hours of research and there is no way around this awful bundling system
// The most popular language in the world feels like its in its infancy
// what shitholes designed this??

// ^ note from the future: i dont remembe why i wrote this or why i was so angry. that code seems to be missing now.

// LIGHTING
// Initializes the THREE.js lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

// Two opposing directional lights. The opposing light is dimmer. Both lights are angled against each other.
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.75);
directionalLight.position.set(1, 1, 1);
scene.add(directionalLight);
const opposingDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.25);
opposingDirectionalLight.position.set(-1, -1, -1);
scene.add(opposingDirectionalLight);

const path = 'skyboxes/BlueSky/';
const format = '.jpg';
const urls = [
	path + 'bluecloud_ft' + format, path + 'bluecloud_bk' + format,
	path + 'bluecloud_up' + format, path + 'bluecloud_dn' + format,
	path + 'bluecloud_rt' + format, path + 'bluecloud_lf' + format
];
const reflectionCube = new THREE.CubeTextureLoader().load(urls);
reflectionCube.textureSpace = THREE.sRGBEncoding;
reflectionCube.mapping = THREE.CubeReflectionMapping;
scene.background = reflectionCube;

var pmremGenerator = new THREE.PMREMGenerator(renderer);
pmremGenerator.compileEquirectangularShader();

// PLAYER CAMERA
// Initializes the local player's camera, rendered to the canvas
const playerMoveSpeed = 250;
const controls = new PointerLockControls(camera, renderer.domElement);
scene.add(controls.getObject());

// An object that traces the mouse's position in the voxel field.
// This is used to determine where to place objects like dynamite
var mouseRayFollower = new THREE.Mesh(
	new THREE.TorusGeometry(2.5, 0.1, 16, 100),
	new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.15 })
);
scene.add(mouseRayFollower)

// This locks the pointer into the screen, so the player can move the camera without the pointer leaving the screen
renderer.domElement.addEventListener('click', () => controls.lock());

// MOTION CONTROLS
// This is the code that handles the player's motion
const isKeyPressed = {};
document.addEventListener('keydown', (e) => {
	isKeyPressed[e.key.toLowerCase()] = true;
});
document.addEventListener('keyup', (e) => {
	isKeyPressed[e.key.toLowerCase()] = false;
});

// on mousemove LEFT and RIGHT, rotate the player's camera
var mouseMoveTimer = 0;
let weaponLeanDirX = 0, weaponLeanDirZ = 0;
document.addEventListener('mousemove', function (e) {
	if (controls.isLocked === true) {
		if (e.movementX < 0) weaponLeanDirX = -1
		else if (e.movementX > 0) weaponLeanDirX = 1
		mouseMoveTimer = 0;
	}
});
setInterval(() => {
	if (mouseMoveTimer > 1) {
		weaponLeanDirZ = 0;
		weaponLeanDirX = 0;
	}
	mouseMoveTimer++;
}, 10);

// This is a function that can clamp two numbers within a range.
// For some reason, it doesn't seem to exist in Vanilla JS? so we must write one ourselves:
const clamp = (value, min, max) => Math.max(min, Math.min(value, max));

// FILESYSTEM CONSTANTS
// These mark locations in the local file system that store the map and current weapon
const modelURL = 'savedata';
const weaponURL = 'weapons/' + 'smg/smg';
// This stores any JSON data that is loaded from the file system, on the main thread.
// Since only one thread can access the file system at a time, it is convenient to store the data here.
// TODO - this explanation sucks. just pass it between functions. too many globals.

// WEAPON DATA
// These objects store data on the currently selected weapon, globally.
// They are global so we can access them from anywhere in the script, if necessary.
var weaponRange = 500,
	weaponPosition,
	weaponRotation,
	weaponRealWorldScaleMultiplier,
	weaponPlacementOffset,
	weaponHelpText,
	weaponType,
	adsPosition,
	adsRotation,
	weaponDamage,
	fireRate, // time in ms in between attacks()
	destroyedChunkRange, // max distance for voxel destruction from intersection
	percentMissedHits // minimum % that must be destroyed

const instancedWorldSafetyOffset = new THREE.Vector3(-10000, -10000, -10000); // to account for memory issues when rendering the dead point ... i know it's messy, but it is the most widely compatible solution. sue me.

// This stores every individual displaced voxel that is currently being simulated.
// TODO: Add gc to this, dead voxels still exist in the array. This will lead to memory problems in big maps.
let destroyedVoxels = [];

// This represents a cubic volume where every position with a voxel is labeled as 1, and every position ignoring a voxel is 0.
// The volume is infinite and stores 1s and 0s in a 3D array, along with other relevant information for voxel transformations.
class blockData {
	value
	position
	chunk
	indexInChunk
	face

	constructor(value, position, chunk, indexInChunk, face) {
		this.value = value;
		this.position = position;
		this.chunk = chunk;
		this.indexInChunk = indexInChunk;
		this.face = face;
	}
}
class DiscreteVectorField {
	constructor() {
		this.field = [];
		this.indexInChunkes = {};
	}

	setChunkMinIndex(chunkName, index) {
		if (!this.indexInChunkes[chunkName]) {
			this.indexInChunkes[chunkName] = {
				minIndex: 0,
				maxIndex: 0
			};
		}
		this.indexInChunkes[chunkName].minIndex = index;
	}

	setChunkMaxIndex(chunkName, index) {
		if (!this.indexInChunkes[chunkName]) {
			this.indexInChunkes[chunkName] = {
				minIndex: 0,
				maxIndex: 0
			};
		}
		this.indexInChunkes[chunkName].maxIndex = index;
	}

	getChunkMinIndex(chunkName) {
		return this.indexInChunkes[chunkName].minIndex || 0;
	}

	getChunkMaxIndex(chunkName) {
		return this.indexInChunkes[chunkName].maxIndex || 0;
	}

	// Sets the value of the vector field at the given position
	set(x, y, z, value, indexInChunk, chunk, face=null) {
		x = Math.round(x);
		y = Math.round(y);
		z = Math.round(z);
		if (!this.field[x]) {
			this.field[x] = [];
		}
		if (!this.field[x][y]) {
			this.field[x][y] = [];
		}
		if (!this.field[x][y][z]) {
			this.field[x][y][z] = []
		}
		this.field[x][y][z] = new blockData(
			value,
			new THREE.Vector3(x, y, z),
			chunk,
			indexInChunk,
			face
		);
		if (value == 0)
		{
			// for holeBorder processing
			chunk.deadVoxels.push([x, y, z]);
		}
	}

	// Retrieves the value of the vector field at the given position
	// 0 if none
	get(x, y, z) {
		if (this.field[x] && this.field[x][y] && this.field[x][y][z]) {
			return this.field[x][y][z];
		}
		return null;
	}

	// Shoots a "ray" with direction, origin, and length
	// Returns the first position where the ray intersects a voxel
	// Origin: Starting Position
	// Direction: Normalized Vector (ex. [0, 1, 0] is up from the origin)
	// Length: The maximum number of steps to take. If the ray does not intersect a voxel, return null
	raycast(origin, direction, length) {
		let x = Math.round(origin.x);
		let y = Math.round(origin.y);
		let z = Math.round(origin.z);

		const sqrMagnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);

		direction.x /= sqrMagnitude;
		direction.y /= sqrMagnitude;
		direction.z /= sqrMagnitude;
		for (let i = 0; i < length; i++) {
			const stepVoxel = this.get(Math.floor(x), Math.floor(y), Math.floor(z));
			if (stepVoxel != null && stepVoxel.value == 1) {
				return {
					x: Math.floor(x),
					y: Math.floor(y),
					z: Math.floor(z),
					index: stepVoxel.indexInChunk,
					chunk: stepVoxel.chunk
				};
			}
			x += direction.x;
			y += direction.y;
			z += direction.z;
		}
		return null; // TODO: js hates nulls, switch to 0 or change get() to return null as well
	}

	// pretty useless implementation
	// TODO: make this useful???
	toString() {
		let str = '';
		for (let x in this.field) {
			for (let y in this.field[x]) {
				for (let z in this.field[x][y]) {
					if (this.field[x][y][z].value === 1) {
						str += '1';
					} else {
						str += '0';
					}
				}
				str += ' ';
			}
		}
		return str;
	}
}
// This initializes the voxelField used for physics calculations
// This engine uses a two-fold representation of voxel data.
// One is stored in main memory (RAM), and the other is stored in GPU memory (vRAM)
// the GPU memory is used to render and display millions of voxels in as few draw calls as possible (the higher squareChunkSize, the fewer)
// the CPU memory is used to store the positions of these voxels, and use them for physics (such as raycasting, explosions, etc)
const voxelField = new DiscreteVectorField();

// This starts building the map, loaded from modelURL (at the top of the file)
// It attempts to load the JSON file, and allows quick transformations to the file (if needed / between versions) before calling buildWorldModel(), which actually builds the instanceMeshes
// (Only one map can be loaded at once... unless?)
// TODO - origin offsets for multiple map loading?
//  ^ this is very unncessary but could be useful for features like streaming
const crouchDepth = 7.5;
const crouchSpeed = 7.5;
const playerHeight = 60;
const crouchYPosition = playerHeight - crouchDepth;

// CUTAWAYS: These allow map builders to make "cuts" in the map, using either cuboids or spheres
// They act as a pre-filter for the world builder, masking out sections voxels should NOT be placed at
const cutawayField = new DiscreteVectorField();
const addToCutawayStack = function(scale, position) {
	console.log("Added a cutaway at " + position.x + ", " + position.y + ", " + position.z + " with scale " + scale);
	for (let x = position.x - (scale.x / 2); x < position.x + (scale.x / 2); x++) {
		for (let y = position.y - (scale.y / 2); y < position.y + (scale.y / 2); y++) {
			for (let z = position.z - (scale.z / 2); z < position.z + (scale.z / 2); z++) {
				cutawayField.set(x, y, z, 1);
			}
		}
	}
}

let groundSize;
const generateWorld = function (modelURL) {

	// send IPC message 'list-maps' and wait for response (sends eventResponse)
	// TODO - make this a promise
	ipcRenderer.send('list-maps');
	ipcRenderer.on('list-maps-reply', (event, arg) => {
		// THIS LISTS ALL AVAILABLE MAPS (later: map selector)
		// console.log(arg);

		// THIS CHOOSES THE MAP TO LOAD
		ipcRenderer.send('get-map-metadata', {
			mapName: modelURL
		});

		// THIS GETS METADATA (PRELOAD)
		ipcRenderer.on('get-map-metadata-reply', (event, arg) => {
			console.log("RECEIVED METADATA [ONLY SEE ONCE]");

			const mapCameraData = {
				position: JSON.parse(arg.metaData).cameraData.cameraPosition,
				rotation: JSON.parse(arg.metaData).cameraData.cameraRotation
			};
			camera.position.set(mapCameraData.position.x, playerHeight, mapCameraData.position.z);
			camera.rotation.set(mapCameraData.rotation.x, mapCameraData.rotation.y, mapCameraData.rotation.z);

			const groundData = JSON.parse(arg.metaData).groundData;
			groundSize = groundData.groundSize;
			if (groundData) {
				const groundFloor = new THREE.Mesh(
					new THREE.BoxGeometry(groundSize.x, 1, groundSize.y),
					new THREE.MeshBasicMaterial({
						color: new THREE.Color(groundData.groundColor.r, groundData.groundColor.g, groundData.groundColor.b),
					})
				);
				groundFloor.position.y = -1; // we set it just below the origin, to act as a floor
				scene.add(groundFloor);
			}

			const mapObjects = JSON.parse(arg.metaData).mapMakerSave;

			// Filter 1: Cutaways
			// These must be processed BEFORE boxes, but by nature can exist in save files in random order
			mapObjects.forEach(mapObject => {
				if (mapObject.type == "box" && mapObject.isCutaway == true)
				{
					addToCutawayStack(mapObject.size, mapObject.position);
					mapObjects.splice(mapObjects.indexOf(mapObject), 1);
				}
			});

			// Filter 2: Boxes
			// These are the most standard world object, and are the quickest to process
			mapObjects.forEach(mapObject => {
				if (mapObject.type == "box") {
					const mod = 1;
					const scale = mapObject.size;
					scale.x /= mod;
					scale.y /= mod;
					scale.z /= mod;
					scale.x = Math.round(scale.x);
					scale.y = Math.round(scale.y);
					scale.z = Math.round(scale.z);
					const position = mapObject.position;
					position.x /= mod;
					position.y /= mod;
					position.z /= mod;
					position.x = Math.round(position.x);
					position.y = Math.round(position.y);
					position.z = Math.round(position.z);
					const color = mapObject.color;

					// shift position (to center it)
					position.x -= scale.x / 2;
					position.y -= scale.y / 2;
					position.z -= scale.z / 2;

					// Normal Objects (Boxes)
					buildWorldModelFromBox(scale, position, mapObject.material, color);
				}
			});
		});
	});
}
// VOXEL OBJECT DATA
let voxelGeometry = new THREE.BoxGeometry(1, 1, 1);
const voxelMaterial = new THREE.MeshBasicMaterial({
	color: 0xffffff
});

// Maximum size for chunking
// Lower size = fewer chunks
// It is best to alter this dynamically between maps for performance
// TODO implement some algorithm to determine this value on the fly
const squareChunkSize = 64;

let instancedModelIndex = []; // An index of all instancedMeshes (which for my own sake, are called Models instead)
// on click of "F", set visible = false for all models
document.addEventListener('keydown', (event) => {
	if (event.key == "f") {
		instancedModelIndex.forEach(model => {
			model.visible = false;
		});
	}
});
const buildWorldModelFromBox = function (scale, position, material, color) {
	// round the position
	position.x = Math.round(position.x);
	position.y = Math.round(position.y);
	position.z = Math.round(position.z);

	// // create a transparent box around the whole thing
	// const box = new THREE.Mesh(
	// 	new THREE.BoxGeometry(scale.x + 1, scale.y + 1, scale.z + 1),
	// 	new THREE.MeshBasicMaterial({
	// 		color: 0x000000,
	// 		transparent: true,
	// 		opacity: 0.5
	// 	})
	// );
	// // offset for center
	// box.position.x = position.x + scale.x / 2;
	// box.position.y = position.y + scale.y / 2;
	// box.position.z = position.z + scale.z / 2;
	// scene.add(box);

	const texturePath = 'textures/' + material + '.png';
	const manager = new THREE.LoadingManager();
	let pixelData;
	manager.onLoad = function () {
		pixelData = getPixelsFromImage(pixelData.image);
		const getPixelColorAt = function(x, y) {
			// pixelData is 32 arrays of 32. Each array is a row of pixels
			// x and y can be beyond 32, but it will wrap around
			x = x % 32;
			y = y % 32;
			const data = pixelData[x][y];
			return new THREE.Color(data[0] / 255, data[1] / 255, data[2] / 255);
		}

		// compute the chunk
		var debugModeChunkColor = new THREE.Color(0xffffff * Math.random());
		let chunkCounter = 0;
		var chunkMinPosition, chunkMaxPosition;
		const resetChunkBounds = function () {
			// For every chunk ...
			chunkMinPosition = new THREE.Vector3(
				Number.MAX_SAFE_INTEGER,
				Number.MAX_SAFE_INTEGER,
				Number.MAX_SAFE_INTEGER
			);
			chunkMaxPosition = new THREE.Vector3(
				Number.MIN_SAFE_INTEGER,
				Number.MIN_SAFE_INTEGER,
				Number.MIN_SAFE_INTEGER
			);
		}
		resetChunkBounds();

		let instancedWorldModel, localVoxelIterator;
		const resetInstancedWorldModel = function() {
			instancedWorldModel = new VoxelChunk(
				voxelGeometry,
				voxelMaterial.clone(),
				squareChunkSize * squareChunkSize
			);
			instancedWorldModel.visible = false;
			instancedWorldModel.position.copy(instancedWorldSafetyOffset);
			instancedWorldModel.name = chunkCounter.toString();
			localVoxelIterator = 0;
			chunkCounter++;
			instancedWorldModel.frustumCulled = false;
		}
		resetInstancedWorldModel();

		const finalizeChunk = function (voxelFace, isAbnormal=false, customColor=new THREE.Color(0xffffff)) {
			if (voxelFace != VoxelFace.BOTTOM) return;
			instancedWorldModel.visible = false;
			
			debugModeChunkColor = new THREE.Color(0xffffff * Math.random());

			instancedWorldModel.instanceMatrix.needsUpdate = true;
			scene.add(instancedWorldModel);
			instancedModelIndex.push(instancedWorldModel);

			// // For Frustum Culling...
			instancedWorldModel.frustumBox = new THREE.Box3();
			instancedWorldModel.frustumBox.setFromCenterAndSize(
				// Determine Center
				new THREE.Vector3(
					(chunkMinPosition.x + chunkMaxPosition.x) / 2,
					(chunkMinPosition.y + chunkMaxPosition.y) / 2,
					(chunkMinPosition.z + chunkMaxPosition.z) / 2
				),
				// Determine Size
				new THREE.Vector3(
					(chunkMaxPosition.x - chunkMinPosition.x),
					(chunkMaxPosition.y - chunkMinPosition.y),
					(chunkMaxPosition.z - chunkMinPosition.z)
				)
			);
			// createa  wireframe box to visualize the frustum box
			const frustumBoxHelper = new THREE.Box3Helper(instancedWorldModel.frustumBox, 0xffff00);
			scene.add(frustumBoxHelper);

			// create a cover box with the same dimensions and position as the frustum box
			const coverBox = new THREE.Mesh(
				new THREE.BoxGeometry(1,1,1),
				new THREE.MeshBasicMaterial({
					map: texture,
					color: customColor
				})
			);
			coverBox.scale.set(
				instancedWorldModel.frustumBox.max.x - instancedWorldModel.frustumBox.min.x + 1,
				instancedWorldModel.frustumBox.max.y - instancedWorldModel.frustumBox.min.y + 1,
				instancedWorldModel.frustumBox.max.z - instancedWorldModel.frustumBox.min.z + 1
			);
			// box.material.map.repeat.set(squareChunkSize,squareChunkSize);
			coverBox.material.map.wrapS = THREE.RepeatWrapping;
			coverBox.material.map.wrapT = THREE.RepeatWrapping;
			coverBox.material.map.magFilter = THREE.NearestFilter;
			coverBox.material.map.minFilter = THREE.NearestFilter;
			coverBox.material.map.repeat.set(
				squareChunkSize / 32,
				squareChunkSize / 32 // 32 is the texture resolution, so it is the [size (in world units) of the chunk / size of the texture]
			);
			instancedWorldModel.frustumBox.getCenter(coverBox.position);
			if (isAbnormal) {
				coverBox.material.map = texture.clone();
				if (voxelFace == VoxelFace.BOTTOM) {
					// get the scale.x and scale.z of this box relative to the squareChunkSize
					// and set the repeat to that
					coverBox.material.map.repeat.multiply(
						new THREE.Vector2(
							(coverBox.scale.x / (squareChunkSize)),
							(coverBox.scale.z / (squareChunkSize))
						)
					);
					if (coverBox.scale.z < squareChunkSize) {
						coverBox.material.map.offset.y = (squareChunkSize - coverBox.scale.z) / (squareChunkSize/2);
					}
				}
			}
			scene.add(coverBox);
			instancedWorldModel.setCoverBox(coverBox);

			// Reset Everything!!
			resetChunkBounds();
			resetInstancedWorldModel();
		}

		const setVoxel = function (voxelPosition,voxelFace,voxelColor) {
			// first, check if a voxel already exists here OR if a cutaway voids voxels from existing here
			if (cutawayField.get(voxelPosition.x, voxelPosition.y, voxelPosition.z) != null) return;
			const voxel = voxelField.get(voxelPosition.x, voxelPosition.y, voxelPosition.z);
			var adjustMinMax = true; // Culling min/max update flag
			if (voxel != null && voxel.value != 0) {
				// removing  clones ...
				voxelPosition = instancedWorldSafetyOffset;
				adjustMinMax = false;
			}
			// Commit to the global voxel field
			voxelField.set(voxelPosition.x, voxelPosition.y, voxelPosition.z, 1, localVoxelIterator, instancedWorldModel, voxelFace); 
			// update min/max positions for this chunk (for culling)
			if (adjustMinMax == true) {
				chunkMinPosition.min(voxelPosition);
				chunkMaxPosition.max(voxelPosition);
			}
			instancedWorldModel.setMatrixAt(localVoxelIterator, new THREE.Matrix4().setPosition(new THREE.Vector3(voxelPosition.x - instancedWorldSafetyOffset.x, voxelPosition.y - instancedWorldSafetyOffset.y, voxelPosition.z - instancedWorldSafetyOffset.z)));
			voxelColor.multiply(color);
			if (USERSETTINGS.debugMode == true) voxelColor = debugModeChunkColor;
			instancedWorldModel.setColorAt(localVoxelIterator, voxelColor);
			// check if we need to create a new chunk
			localVoxelIterator++;
		}

		// Create the FLOOR (bottom) of the box:
		console.log("TOTAL SIZE: " + Math.ceil(scale.x/squareChunkSize), Math.ceil(scale.z/squareChunkSize));
		console.log("TOTAL NUM OF CHUNKS: " + Math.ceil(scale.x/squareChunkSize) * Math.ceil(scale.z/squareChunkSize));
		console.log("SCALE: " + scale.x, scale.z);
		for (let x = 0; x < Math.ceil(scale.x/squareChunkSize); x++)
		{
			for (let z = 0; z < Math.ceil(scale.z/squareChunkSize); z++)
			{
				let isFullChunk = true;
				let thisChunkSizeX = squareChunkSize;
				let thisChunkSizeZ = squareChunkSize;
				for (let i = 0; i < thisChunkSizeX; i++)
				{
					for (let j = 0; j < thisChunkSizeZ; j++)
					{
						const voxelPosition = new THREE.Vector3(position.x + x*squareChunkSize + i, position.y, position.z + z*squareChunkSize + j);
						// if the point is within the box:
						if (voxelPosition.x >= position.x && voxelPosition.x <= position.x + scale.x && voxelPosition.z >= position.z && voxelPosition.z <= position.z + scale.z)
						{
							// we set the voxel at this position
							setVoxel(voxelPosition, VoxelFace.BOTTOM, getPixelColorAt(x * thisChunkSizeX + i, z * thisChunkSizeZ + j));
						}
						else
						{
							isFullChunk = false;
						}
					}
				}
				let col = new THREE.Color(0xffffff);
				if (isFullChunk == false) col.multiplyScalar(0.75);
				const singleUnitSize = 1/32;

				// we finalize this chunk
				finalizeChunk(VoxelFace.BOTTOM, !isFullChunk, col);
			}
		}

		// Create the ROOF (top) of the box:
		for (let x = 0; x < Math.ceil(scale.x/squareChunkSize); x++)
		{
			for (let z = 0; z < Math.ceil(scale.z/squareChunkSize); z++)
			{
				let isFullChunk = true;
				let thisChunkSizeX = squareChunkSize;
				let thisChunkSizeZ = squareChunkSize;
				for (let i = 0; i < thisChunkSizeX; i++)
				{
					for (let j = 0; j < thisChunkSizeZ; j++)
					{
						const voxelPosition = new THREE.Vector3(position.x + x*squareChunkSize + i, position.y + scale.y, position.z + z*squareChunkSize + j);
						// if the point is within the box:
						if (voxelPosition.x >= position.x && voxelPosition.x <= position.x + scale.x && voxelPosition.z >= position.z && voxelPosition.z <= position.z + scale.z)
						{
							// we set the voxel at this position
							setVoxel(voxelPosition, VoxelFace.TOP, getPixelColorAt(x + i, z + j));
						}
						else
						{
							isFullChunk = false;
						}
					}
				}
				// we finalize this chunk
				finalizeChunk(VoxelFace.TOP, !isFullChunk);
			}
		}

		// Create the LEFT WALL of the box:
		for (let y = 0; y < Math.ceil(scale.y/squareChunkSize); y++)
		{
			for (let z = 0; z < Math.ceil(scale.z/squareChunkSize); z++)
			{
				let isFullChunk = true;
				let thisChunkSizeY = squareChunkSize;
				let thisChunkSizeZ = squareChunkSize;
				for (let i = 0; i < thisChunkSizeY; i++)
				{
					for (let j = 0; j < thisChunkSizeZ; j++)
					{
						const voxelPosition = new THREE.Vector3(position.x, position.y + y*squareChunkSize + i, position.z + z*squareChunkSize + j);
						// if the point is within the box:
						if (voxelPosition.y >= position.y && voxelPosition.y <= position.y + scale.y && voxelPosition.z >= position.z && voxelPosition.z <= position.z + scale.z)
						{
							// we set the voxel at this position
							setVoxel(voxelPosition, VoxelFace.LEFT, getPixelColorAt(y + i, z + j));
						}
						else
						{
							isFullChunk = false;
						}
					}
				}
				// we finalize this chunk
				finalizeChunk(VoxelFace.LEFT, !isFullChunk);
			}
		}

		// Create the RIGHT WALL of the box:
		for (let y = 0; y < Math.ceil(scale.y/squareChunkSize); y++)
		{
			for (let z = 0; z < Math.ceil(scale.z/squareChunkSize); z++)
			{
				let isFullChunk = true;
				let thisChunkSizeY = squareChunkSize;
				let thisChunkSizeZ = squareChunkSize;
				for (let i = 0; i < thisChunkSizeY; i++)
				{
					for (let j = 0; j < thisChunkSizeZ; j++)
					{
						const voxelPosition = new THREE.Vector3(position.x + scale.x, position.y + y*squareChunkSize + i, position.z + z*squareChunkSize + j);
						// if the point is within the box:
						if (voxelPosition.y >= position.y && voxelPosition.y <= position.y + scale.y && voxelPosition.z >= position.z && voxelPosition.z <= position.z + scale.z)
						{
							// we set the voxel at this position
							setVoxel(voxelPosition, VoxelFace.RIGHT, getPixelColorAt(y + i, z + j));
						}
						else
						{
							isFullChunk = false;
						}
					}
				}
				// we finalize this chunk
				finalizeChunk(VoxelFace.RIGHT, !isFullChunk);
			}
		}

	};
	const loader = new THREE.TextureLoader(manager);
	const texture = loader.load(texturePath, (texture) => {
		pixelData = texture;
	});
}

const buildWorldModelFromSphere = function (position, scale, color) {
	// TODO
}

generateWorld(modelURL); // finally, we load and generate the model!

// TODO i realize i wrote most of this while high out of my mind but this function chain might be the worst piece of code i've ever written
// like there are two wholly unnecessary, single-use function calls here for the same exact thing?
// maybe in a networked game it may be necessary ... maybe it's not so dumb after all ...
// ill look into it later.

var weaponModel;
const weaponModelMaterial = new THREE.MeshStandardMaterial({
	// highly reflective for funzies / make it contrast
	envMap: reflectionCube,
	roughness: 1.0,
	color: 0x8c8c8c
});

var weaponTarget; // target position for instancedWeapon (for lerping :P)

// This will add the player's weapon model to the scene
const generateWeaponModel = function (basePath) {
	// First, load the weapon metadata from the .json file
	let jsonLoader = new THREE.FileLoader();
	jsonLoader.load(
		basePath + '.json',
		function (json) {
			let jsonModel = JSON.parse(json);

			// Once the metadata is loaded, we must load in the fbx model of the weapon and assign attributes
			globalModelLoader.load(
			basePath + '.fbx',
			function (object) {
				weaponModel = object;
				// Load in the texture for the weapon
				weaponModel.children[0].material.map = globalTextureLoader.load(basePath + '.png');
				// Adjust the scale from standard magicavoxel scaling
				weaponModel.scale.divideScalar(15);
				weaponModel.renderOrder = 999999;
				weaponModel.name = jsonModel.weaponData.name;
				weaponTarget = new THREE.Mesh(
					new THREE.BoxGeometry(1, 1, 1),
					new THREE.MeshBasicMaterial({color: 0x00ff00})
				);
				weaponTarget.material.visible = false; // uncomment to position weapon better
				camera.add(weaponTarget);
				// json reads for weapon data
				weaponType = jsonModel.weaponData.type;
				adsPosition = jsonModel.weaponData.adsPosition;
				adsRotation = jsonModel.weaponData.adsRotation;
				percentMissedHits = jsonModel.weaponData.basepotency;
				destroyedChunkRange = jsonModel.weaponData.damageRange;
				fireRate = jsonModel.weaponData.fireRate;
				weaponDamage = jsonModel.weaponData.weaponDamage;
				weaponHelpText = jsonModel.weaponData.helpText;
				// finally, add the weapon to the scene
				scene.add(weaponModel);
				weaponPosition = new THREE.Vector3(jsonModel.weaponData.position.x, jsonModel.weaponData.position.y, jsonModel.weaponData.position.z);
				if (jsonModel.weaponData.placementOffset) weaponPlacementOffset = new THREE.Vector3(jsonModel.weaponData.placementOffset.x, jsonModel.weaponData.placementOffset.y, jsonModel.weaponData.placementOffset.z);
				weaponRange = jsonModel.weaponData.minimumDistance;
				if (jsonModel.weaponData.realWorldScaleMultiplier != undefined) weaponRealWorldScaleMultiplier = jsonModel.weaponData.realWorldScaleMultiplier;
				weaponTarget.position.copy(weaponPosition);

				// add a clone of the weaponModel as a child of itself, shifted to the left by 5 units
				// const weaponModelClone = weaponModel.clone();
				// weaponModelClone.scale.multiplyScalar(15);
				// weaponModelClone.position.z -= 865;
				// weaponModel.add(weaponModelClone);


				// DEBUG KEYS to move weapon target around, see what looks best :)
				document.addEventListener('keydown', function (event) {
					if (event.key == 'ArrowLeft') {
						weaponTarget.position.x -= 1;
						console.log(weaponTarget.position);
					}
					if (event.key == 'ArrowRight') {
						weaponTarget.position.x += 1;
						console.log(weaponTarget.position);
					}
					if (event.key == 'ArrowUp') {
						weaponTarget.position.y += 1;
						console.log(weaponTarget.position);
					}
					if (event.key == 'ArrowDown') {
						weaponTarget.position.y -= 1;
						console.log(weaponTarget.position);
					}
					if (event.key == '1') {
						weaponTarget.position.z -= 1;
						console.log(weaponTarget.position);
					}
					if (event.key == '2') {
						weaponTarget.position.z += 1;
						console.log(weaponTarget.position);
					}
					if (event.key == '3') {
						weaponTarget.rotation.z += Math.PI / 100;
					}
					if (event.key == '4') {
						weaponTarget.rotation.z -= Math.PI / 100;
						console.log(weaponTarget.rotation);
					}
					if (event.key == '5') {
						weaponTarget.rotation.y += Math.PI / 100;
					}
					if (event.key == '6') {
						weaponTarget.rotation.y -= Math.PI / 100;
						console.log(weaponTarget.rotation);
					}
				});
				weaponRotation = new THREE.Euler(jsonModel.weaponData.rotation.x, jsonModel.weaponData.rotation.y, jsonModel.weaponData.rotation.z);
				weaponTarget.rotation.copy(weaponRotation);
				if (weaponHelpText) setHelpText(weaponHelpText);
			},
			function (err) {
				// console.log(err);
			}
		);
	});
}

generateWeaponModel(weaponURL); // same as map, but for the weapon!

const triVoxelDroppedPieces = [];
const createTrivoxelAt = function (x, y, z, color) {
	return;
	const triVoxel = new THREE.Mesh(
		// cone with minimal segments
		new THREE.BoxGeometry(1, 1, 1),
		new THREE.MeshStandardMaterial({ color: color })
	);
	// for some reason i named the destroyed pieces of a mesh 'trivoxels', prolly cuz they were originally triangular prisms.
	// that has changed since, but the name still slaps.
	triVoxel.name = "TRIVOXEL-" + Math.random();
	scene.add(triVoxel);
	x = parseInt(x);
	y = parseInt(y);
	z = parseInt(z);
	triVoxel.position.set(x, y, z);

	// velocity (random)
	const velocityRange = 0.25;
	const dropAngleModifier = 50;
	const dropAngle = Math.floor(Math.random() * dropAngleModifier) - (dropAngleModifier / 2);
	const triVoxelVelocity = new THREE.Vector3(
		(Math.random() * velocityRange / dropAngle) - (velocityRange / dropAngle),
		(Math.random() * velocityRange / (dropAngle / 5)) - (velocityRange / (dropAngle / 5)),
		(Math.random() * velocityRange / dropAngle) - (velocityRange / dropAngle)
	);

	// normalize the velocity
	triVoxelVelocity.normalize();

	triVoxelDroppedPieces.push({
		"sceneObject": triVoxel,
		"velocity": triVoxelVelocity
	});
}

class ParticleEffect {
	count
	lifetime
	color
	size
	spread
	direction
	filePath
	useRandomSprite
	randomSpriteRange
	useGravity
	fadeOut

	constructor(count, lifetime, color, size, spread, direction, filePath, useRandomSprite, randomSpriteRange, useGravity, fadeOut) {
		this.count = count;
		this.lifetime = lifetime;
		this.color = color;
		this.size = size;
		this.spread = spread;
		this.direction = direction;
		this.filePath = filePath;
		this.useRandomSprite = useRandomSprite;
		this.randomSpriteRange = randomSpriteRange;
		this.useGravity = useGravity;
		this.fadeOut = fadeOut;
	}
}

const particleInstances = [];
const createParticleInstance = function (effect, worldPos) {
	return;
	var path = effect.filePath;
	if (effect.useRandomSprite) {
		var num = Math.floor(Math.random() * effect.randomSpriteRange);
		if (num != 0) {
			path += num
		}
		path += ".png";
	}
	const particleTexture = globalTextureLoader.load(path);
	const particleMaterial = new THREE.PointsMaterial({
		map: particleTexture,
		color: effect.color,
		size: effect.size
	});

	// randomize the color a bit
	const rand = Math.random() / 5;
	particleMaterial.color.r += rand;
	particleMaterial.color.g += rand;
	particleMaterial.color.b += rand;

	const particleGeometry = new THREE.BufferGeometry();
	const particlePositions = [];
	const particleVelocities = [];
	const particleLifetimes = [];

	for (let i = 0; i < effect.count; i++) {
		particlePositions.push(
			(Math.random() * effect.spread.x) - (effect.spread.x / 2),
			(Math.random() * effect.spread.y) - (effect.spread.y / 2),
			(Math.random() * effect.spread.z) - (effect.spread.z / 2)
		);
		particleVelocities.push(
			effect.direction.x * (Math.random() + 0.5),
			effect.direction.y * (Math.random() + 0.5),
			effect.direction.z * (Math.random() + 0.5)
		);
		particleLifetimes.push(0);
	}

	const particleSystem = new ParticleMesh(particleGeometry, particleMaterial);
	// no billboarding

	particleSystem.frustumCulled = false;

	particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
	particleSystem.velocities = particleVelocities;
	particleSystem.lifetimes = particleLifetimes;
	particleSystem.lifetime = effect.lifetime;

	particleSystem.position.copy(worldPos);
	particleInstances.push(particleSystem);

	scene.add(particleSystem);
}

const dropSounds = [
	new Howl({
		src: ['sfx/lego_drop.wav'],
		volume: SFXVolume
	}),
	new Howl({
		src: ['sfx/lego_drop_2.wav'],
		volume: SFXVolume * 3
	}),
	new Howl({
		src: ['sfx/lego_drop_3.wav'],
		volume: SFXVolume
	}),
	new Howl({
		src: ['sfx/lego_drop_4.wav'],
		volume: SFXVolume
	})
]

const bigDropSounds = [
	new Howl({
		src: ['sfx/big_drop.wav'],
		volume: SFXVolume * 7.5
	})
]

const generateDestroyedChunkAt = function (destroyedVoxelsInChunk, trivoxelChance = 0.25) {
	let found = false;
	for (let x = 0; x < destroyedVoxelsInChunk.length; x++) {
		let position = destroyedVoxelsInChunk[x];
		const thisVoxel = voxelField.get(position.x, position.y, position.z);
		if (thisVoxel != null && thisVoxel.value != 0) {
			thisVoxel.chunk.uncover();
			thisVoxel.chunk.setMatrixAt(thisVoxel.indexInChunk, new THREE.Matrix4().makeTranslation(instancedWorldSafetyOffset.x, instancedWorldSafetyOffset.y, instancedWorldSafetyOffset.z));
			thisVoxel.chunk.instanceMatrix.needsUpdate = true;
			voxelField.set(position.x, position.y, position.z, 0, thisVoxel.indexInChunk, thisVoxel.chunk);
			const soundToPlay = Math.floor(Math.random() * dropSounds.length);
			dropSounds[soundToPlay].rate(Math.random() + 0.45);
			dropSounds[soundToPlay].play();
			if (Math.random() < trivoxelChance) {
				const color = new THREE.Color();
				thisVoxel.chunk.getColorAt(thisVoxel.indexInChunk, color);
				createTrivoxelAt(position.x, position.y, position.z, color);
			}
		}
	}
}

// MOUSE BUTTONS
var isLeftClicking = false;
document.addEventListener('mousedown', (e) => { if (e.button != 0) return; isLeftClicking = true; });
document.addEventListener('mouseup', (e) => { if (e.button != 0) return; isLeftClicking = false; });
var isRightClicking = false;
document.addEventListener('mousedown', (e) => { if (e.button != 2) return; isRightClicking = true; });
document.addEventListener('mouseup', (e) => { if (e.button != 2) return; isRightClicking = false; });

var isAttackAvailable = true;

/*

public static float Berp(float start, float end, float value)
{
	value = Mathf.Clamp01(value);
	value = (Mathf.Sin(value * Mathf.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + (1.2f * (1f - value)));
	return start + (end - start) * value;
}

*/

const elasticLerp = function (a, b, t) {
	t = Math.min(Math.max(t, 0), 0.25);
	t = (Math.sin(t * Math.PI * (0.2 + 2.5 * t * t * t)) * Math.pow(1 - t, 0.2) + t) * (1 + (0.1 * (1 - t)));
	return a + (b - a) * t;
}


// ### RENDER LOOP ###
// this renders things. separate from the physics loop.
const clock = new THREE.Clock();
var frameCounter = 0;
var defaultInstancedWeaponTargetPosition;
var crouchLerp = 0;
var loaderRemoved = false;
const raycaster = new THREE.Raycaster();

const hitSound = new Howl({
	src: ['sfx/hit_ding.wav'],
	volume: SFXVolume
})

const shootSound = new Howl({
	src: ['sfx/shoot.wav'],
	volume: SFXVolume * 3
});

const moveTowards = function(vectorA, vectorB, step) {
	const difference = vectorB.clone().sub(vectorA);
	if (difference.length() < step) {
		return vectorB;
	}
	return vectorA.clone().add(difference.normalize().multiplyScalar(step));
}

const shootLine = function(vec) {
	const newLine = new THREE.LineSegments(
		new THREE.BufferGeometry().setFromPoints([
			camera.position,
			vec
		]),
		new THREE.LineBasicMaterial({
			color: 0xcccccc
		})
	);
	scene.add(newLine);
}

const render = function () {
	// Frame Calculations
	if (!loaderRemoved && frameCounter > 10){
		document.querySelector("#loader-bg").style.animation = "fade-out 0.25s ease";
		setTimeout(() => {document.querySelector("#loader-bg").remove()}, 250);
		loaderRemoved = true;
		setHelpText("[WASD] Move [Mouse] Look");
		paneParent.style.opacity = 1;
	}
	frameCounter = (frameCounter + 1) % 60;
	const delta = clock.getDelta();
	frameInfo.FPS = Math.round(1 / delta);
	frameInfo.frameTime = delta;
	// Update NPC Motion
	NPCBank.forEach(npc => {
		npc.update(delta);
	});
	// Player Motion
	let isCrouching = isKeyPressed["control"];
	let zAxis = 0;
	if (isKeyPressed["s"]) zAxis += 1 * delta;
	if (isKeyPressed["w"]) zAxis -= 1 * delta;
	zAxis = clamp(zAxis, -1, 1);
	let xAxis = 0;
	if (isKeyPressed["d"]) xAxis += 1 * delta;
	if (isKeyPressed["a"]) xAxis -= 1 * delta;
	xAxis = clamp(xAxis, -0.1, 0.1);
	let sprinting = isKeyPressed["shift"] ? 2 : 1;
	controls.moveRight(playerMoveSpeed * xAxis * sprinting);
	controls.moveForward(-playerMoveSpeed * zAxis * sprinting);
	// Overlay Updates
	positionOverlayValue.x = Math.round(controls.getObject().position.x);
	positionOverlayValue.y = Math.round(controls.getObject().position.y);
	positionOverlayValue.z = Math.round(controls.getObject().position.z);
	if (isCrouching) {
		camera.position.y = lerp(playerHeight, crouchYPosition, crouchLerp);
		crouchLerp += crouchSpeed * delta;
		if (crouchLerp > 1) crouchLerp = 1;
	}
	else {
		var headPosition = playerHeight
		if (zAxis != 0 || xAxis != 0) {
			const freq = 75;
			const strength = 2.5;
			headPosition = playerHeight + (Math.sin(Date.now() / freq) * strength);
		}
		camera.position.y = lerp(camera.position.y, headPosition, delta * 10);
		crouchLerp -= crouchSpeed * delta;
		if (crouchLerp < 0) crouchLerp = 0;
	}
	if (weaponModel && weaponTarget && delta > 0) {
		if (!defaultInstancedWeaponTargetPosition) defaultInstancedWeaponTargetPosition = weaponTarget.position.clone();

		// SIN the weapon's position
		const bounceRange = new THREE.Vector3(0.25, 0.25, 0);
		let speed = new THREE.Vector3(100, 50, 100);
		let isMoving = false;
		if (xAxis != 0 || zAxis != 0) {
			isMoving = true;
		}
		else if (mouseMoveTimer == 0 && controls.isLocked == true) {
			isMoving = true;
			bounceRange.divideScalar(2.5);
			speed.multiplyScalar(2.5);
		}
		weaponTarget.position.x += (Math.sin(Date.now() / speed.x) * bounceRange.x) * (isMoving);
		weaponTarget.position.y += (Math.sin(Date.now() / speed.y) * bounceRange.y) * (isMoving);

		// LERP the weapon's position
		const instancedWeaponTargetWorldPosition = new THREE.Vector3();
		weaponTarget.getWorldPosition(instancedWeaponTargetWorldPosition);
		weaponModel.position.copy(moveTowards(weaponModel.position, instancedWeaponTargetWorldPosition, delta * 1000));

		// always realign the rotation of the weapon to the target
		weaponModel.rotation.setFromRotationMatrix(weaponTarget.matrixWorld);
	}
	if (isRightClicking) {
		switch (weaponType) {
			case undefined:
				break;
			default:
				console.error("Illegal Weapon Type - \"" + weaponType + "\"");
				break;
			case "ranged":
				weaponTarget.position.set(adsPosition.x, adsPosition.y, adsPosition.z);
				weaponTarget.rotation.set(adsRotation.x, adsRotation.y, adsRotation.z);
		}
	}
	else
	{
		if (weaponTarget) weaponTarget.position.set(weaponPosition.x, weaponPosition.y, weaponPosition.z);
	}
	if (isLeftClicking) {
		switch (weaponType) {
			case undefined:
				break;
			default:
				console.error("Illegal Weapon Type - \"" + weaponType + "\"");
				break;
			case "ranged":
				if (isAttackAvailable) {
					if (!isRightClicking) {
						const weaponShakeIntensity = 2.5;
						weaponTarget.position.set(
							weaponPosition.x + Math.random() * weaponShakeIntensity - weaponShakeIntensity / 2 - 0.5,
							weaponPosition.y + Math.random() * weaponShakeIntensity - weaponShakeIntensity / 2 + 0.5,
							weaponPosition.z + Math.random() * weaponShakeIntensity - weaponShakeIntensity / 2 + 0.5
						);
					}

					// Play Sound
					shootSound.rate(2 + Math.random());
					shootSound.play();

					// GOD i HATE javascript
					// type annotations? NO.
					// parameter delcarations? NO.
					// return types? NO.
					// why don't i just kill myself now?
					shootRay();
					
					raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
					const intersects = raycaster.intersectObjects(NPCBank.map(npc => npc.sceneObject.children[0]));

					for ( let i = 0; i < intersects.length; i ++ ) {
						const mainObj = intersects[i].object;
						// Adjust Color
						mainObj.material.color.r = 20 - (Math.random() * 5);
						// Register Hit
						mainObj.npcHandler.depleteHealth(weaponDamage);
						// Squelch!
						hitSound.rate(clamp(1 + Math.random(), 1, 1.5));
						hitSound.play();
						// create a shoot effect
						shootLine(intersects[i].point);
					}

					isAttackAvailable = false;
					setTimeout(function () {
						isAttackAvailable = true;
					}, fireRate);
				}
				break;
			case "melee":
				// TODO
				break;
			case "explosive":
				if (isAttackAvailable) {

					plantExplosive();

					isAttackAvailable = false;
					setTimeout(function () {
						isAttackAvailable = true;
					}, fireRate);
				}
				break;
		}
	}
	mouseRayFollower.visible = false;
	if (weaponType == "explosive") {
		const cameraCenterPosition = new THREE.Vector3();
		camera.getWorldPosition(cameraCenterPosition);
		const direction = new THREE.Vector3();
		camera.getWorldDirection(direction);
		// const intersect = voxelField.raycast(
		//     cameraCenterPosition,
		//     direction,
		//     weaponRange
		// );
		// if (intersect) {
		//     mouseRayFollower.visible = true;
		//     mouseRayFollower.position.set(intersect.x, intersect.y, intersect.z);
		//     mouseRayFollower.lookAt(cameraCenterPosition);
		// }
	}

	var frustum = new THREE.Frustum();
	frustum.setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));
	instancedModelIndex.forEach(model => {
		if (frustum.intersectsBox(model.frustumBox)) {
			if (model.isCovered) {
				model.coverBox.visible = true;
			}
			else {
				model.visible = true;
			}
		}
		else {
			model.visible = false;
			if (model.isCovered) {
				model.coverBox.visible = false;
			}
		}
	});

	frameInfo.drawCalls = renderer.info.render.calls;
	requestAnimationFrame(render);
	composer.render();
}

// ### PHYSICS LOOPS ###
const physicsUpdatesPerSecond = 60; // physics speed
const cubeDestructionParticlesSimulator = []; // index of all cubedestructionparticle
const wreckedMeshes = [];
const physicsUpdate = function () {
	// UPDATE PARTICLES
	particleInstances.forEach(particleInstance => {
		// for each position in the particle instance, move it by its velocity
		const positions = particleInstance.geometry.attributes.position.array;
		const velocities = particleInstance.velocities;
		const lifetimes = particleInstance.lifetimes;

		let tally = 0;

		for (let i = 0; i < positions.length; i += 3) {
			if (lifetimes[i / 3] > particleInstance.lifetime) {
				// remove from positions (move it to -2 and set velocity to 0)
				positions[i] = -2;
				positions[i + 1] = -2;
				positions[i + 2] = -2;
				velocities[i] = 0;
				velocities[i + 1] = 0;
				velocities[i + 2] = 0;
				lifetimes[i / 3] = 999;
				tally += 1;
				if (tally >= positions.length / 3) {
					scene.remove(particleInstance);
					particleInstances.splice(particleInstances.indexOf(particleInstance), 1);
				}
			}
			else {
				positions[i] += velocities[i];
				positions[i + 1] += velocities[i + 1];
				positions[i + 2] += velocities[i + 2];
				lifetimes[i / 3] += 1 / physicsUpdatesPerSecond;
				particleInstance.material.opacity = 1 - (lifetimes[i / 3] / particleInstance.lifetime);
			}
		}

		particleInstance.geometry.attributes.position.needsUpdate = true;
	})
	// UPDATE TRIVOXELS
	triVoxelDroppedPieces.forEach((triVoxel) => {
		if (Math.random() < 0.1 / physicsUpdatesPerSecond) {
			scene.remove(triVoxel.sceneObject);
			triVoxelDroppedPieces.splice(triVoxelDroppedPieces.indexOf(triVoxel), 1);
		}
		else {
			const sceneObject = triVoxel.sceneObject;
			const velocity = triVoxel.velocity;

			const newPosition = new THREE.Vector3(
				sceneObject.position.x + velocity.x,
				sceneObject.position.y + velocity.y,
				sceneObject.position.z + velocity.z
			);

			// apply some gravity (-1 y)
			// get the position of the first matrix object
			const position = newPosition.clone();

			if (position.y > 1) {
				velocity.y -= 1 / (physicsUpdatesPerSecond / 2);
				sceneObject.position.copy(newPosition);

				// add velocity to rotation ( with 50% chance to be negative )
				sceneObject.rotation.x += velocity.x / 50;
				sceneObject.rotation.y += velocity.y / 50;
				sceneObject.rotation.z += velocity.z / 50;
			}
		}
	});
	if (USERSETTINGS.useSpriteParticles) {
		// UPDATE CUBEDESTRUCTIONPARTICLES (POINTS MESHES)
		cubeDestructionParticlesSimulator.forEach(cubeDestructionParticlesObject => {
			if (Math.random() < 0.000001 / physicsUpdatesPerSecond) {
				scene.remove(cubeDestructionParticlesObject);
				cubeDestructionParticlesSimulator.splice(cubeDestructionParticlesSimulator.indexOf(cubeDestructionParticlesObject), 1);
			}
			else {
				// this is a bufferGeometry with a position attribute
				const cubeDestructionParticles = cubeDestructionParticlesObject.geometry.attributes.position.array;
				// if the length of the geometry is 0, remove this object from scene AND array, then skip
				if (cubeDestructionParticles.length == 0) {
					scene.remove(cubeDestructionParticlesObject);
					cubeDestructionParticlesSimulator.splice(cubeDestructionParticlesSimulator.indexOf(cubeDestructionParticlesObject), 1);
					return;
				}
				for (let i = 0; i < cubeDestructionParticles.length; i += 3) {
					if (Math.random() < 1 / physicsUpdatesPerSecond) {
						// remove this vertex
						cubeDestructionParticles[i] = 0;
						cubeDestructionParticles[i + 1] = 0;
						cubeDestructionParticles[i + 2] = 0;
					}
					else {
						// get the position of the first matrix object
						const position = new THREE.Vector3(
							cubeDestructionParticles[i],
							cubeDestructionParticles[i + 1],
							cubeDestructionParticles[i + 2]
						);
						// apply velocity (they are Vector3s in the cubeDestructionParticlesObject.velocities array)
						position.add(cubeDestructionParticlesObject.velocities[i / 3]);
						// apply position
						// if the world position Y is greater than 0
						if (cubeDestructionParticles[i + 1] > 1) {
							cubeDestructionParticles[i] = position.x;
							cubeDestructionParticles[i + 1] = position.y;
							cubeDestructionParticles[i + 2] = position.z;
						}
					}
				}
				cubeDestructionParticlesObject.geometry.attributes.position.needsUpdate = true;
			}
		});
	}
	// else {
	// 	wreckedMeshes.forEach(wreckedMesh => {
	// 		if (wreckedMesh.count == 0) {
	// 			scene.remove(wreckedMesh);
	// 			wreckedMeshes.splice(wreckedMeshes.indexOf(wreckedMesh), 1);
	// 			return;
	// 		}
	// 		// wreckedMesh is an instancedmesh.
	// 		const matrix = new THREE.Matrix4();
	// 		for (let i = 0; i < wreckedMesh.count; i++) {
	// 			if (Math.random() < 1 / physicsUpdatesPerSecond) {
	// 				wreckedMesh.count--;
	// 				continue;
	// 			}
	// 			const velocity = wreckedMesh.velocities[i];
	// 			// multiply velocity by 1.1
	// 			velocity.multiplyScalar(1.02);
	// 			wreckedMesh.getMatrixAt(i, matrix);
	// 			const position = new THREE.Vector3();
	// 			position.setFromMatrixPosition(matrix);

	// 			// adjust the position by the velocity
	// 			position.add(velocity);

	// 			// apply some gravity (-1 y)
	// 			// get the position of the first matrix object
	// 			if (position.y > 1) {
	// 				velocity.y -= 1 / (physicsUpdatesPerSecond / 2);
	// 				matrix.setPosition(position);
	// 				wreckedMesh.setMatrixAt(i, matrix);
	// 				wreckedMesh.instanceMatrix.needsUpdate = true;
	// 			}
	// 			else {
	// 				if (!wreckedMesh.velocities[i].bounceCount) wreckedMesh.velocities[i].bounceCount = 1;
	// 				wreckedMesh.velocities[i].x /= 2.5;
	// 				wreckedMesh.velocities[i].y = 0.5 / wreckedMesh.velocities[i].bounceCount;
	// 				wreckedMesh.velocities[i].z /= 2.5;
	// 				wreckedMesh.velocities[i].bounceCount++;
	// 			}
	// 		}
	// 	});
	// }
}

setInterval(physicsUpdate, 1000 / physicsUpdatesPerSecond);

const createVizSphere = function (x, y, z, color = 0x00ff00, size = 1.5) {
	const sphere = new THREE.Mesh(
		new THREE.SphereGeometry(size, 2, 2),
		new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.5 })
	);
	sphere.position.set(x, y, z);
	scene.add(sphere);
}

const cubeSprite = globalTextureLoader.load("img/cubesprite.png");
const conjunctionCheckTimesPerSecond = 1;
const recentlyEditedWorldModels = [];
const maxChunksInPhysicsCache = 15;
const conjunctionCheck = function () {

	const holeBorder = [];

	// CONJUNCTION CHECK
	recentlyEditedWorldModels.forEach(instancedModel => {
		const deadVoxels = instancedModel.deadVoxels;
		for (let i = 0; i < deadVoxels.length; i++)
		{
			const thisVector = new THREE.Vector3(
				deadVoxels[i][0],
				deadVoxels[i][1],
				deadVoxels[i][2]
			);
			const voxel = voxelField.get(thisVector.x, thisVector.y, thisVector.z);
			if (voxel != null && voxel.value == 0) {
				holeBorder.push(thisVector);
			}
		}
		// recentlyEditedWorldModels.splice(recentlyEditedWorldModels.indexOf(instancedModel), 1);
	});

	// if all voxels in the holeSet touch each other, then they are a hole.
	const startTime = performance.now();
	const confirmedTouch = [];
	holeBorder.forEach(holeA => {
		const holeApos = new THREE.Vector3(holeA.x, holeA.y, holeA.z);
		holeBorder.forEach(holeB => {
			const holeBpos = new THREE.Vector3(holeB.x, holeB.y, holeB.z);
			if (holeApos.distanceTo(holeBpos) < 2) {
				// if it isnt in the confirmedTouch array, add it
				if (!confirmedTouch.includes(holeA)) {
					confirmedTouch.push(holeA);
				}
			}
		});
	});

	const fullHole = [];
	if (confirmedTouch.length == holeBorder.length) {
		const maxPositions = [];
		const minPositions = [];
		const clearedYPositions = []; // store Y positions that have at LEAST two X,Z positions
		for (let i = 1; i < holeBorder.length; i++) {
			// min positions for EVERY Y LEVEL
			if (minPositions[holeBorder[i].y] == undefined) {
				minPositions[holeBorder[i].y] = holeBorder[i];
			}
			else {
				if (holeBorder[i].x < minPositions[holeBorder[i].y].x) {
					minPositions[holeBorder[i].y] = holeBorder[i];
				}
				if (holeBorder[i].z < minPositions[holeBorder[i].y].z) {
					minPositions[holeBorder[i].y] = holeBorder[i];
				}
			}
			// max positions for EVERY Y LEVEL
			if (maxPositions[holeBorder[i].y] == undefined) {
				maxPositions[holeBorder[i].y] = holeBorder[i];
			}
			else {
				if (holeBorder[i].x > maxPositions[holeBorder[i].y].x) {
					maxPositions[holeBorder[i].y] = holeBorder[i];
				}
				if (holeBorder[i].z > maxPositions[holeBorder[i].y].z) {
					maxPositions[holeBorder[i].y] = holeBorder[i];
				}
			}
		}
		const hasAYPosition = function (x, z) {
			let count = 0;
			for (let i = 0; i < holeBorder.length; i++) {
				if (holeBorder[i].x == x && holeBorder[i].z == z) count++;
				if (count >= 2) return true;
			}
			return false;
		}
		for (let i = 1; i < minPositions.length; i++) {
			const minPos = minPositions[i];
			const maxPos = maxPositions[i];
			if (minPos == undefined || maxPos == undefined) continue;
			// if clearedYpositions does NOT include this Y position, or its length is less than 2, then skip it
			// for every voxel beween min and max, add it to the fullHole array
			for (let x = minPos.x; x <= maxPos.x; x++) {
				for (let z = minPos.z; z <= maxPos.z; z++) {
					const voxel = voxelField.get(x, i, z);
					if (!hasAYPosition(x, z)) continue;
					if (voxel.value == 1) {
						voxelField.set(x, i, z, 2, voxel.indexInChunk, voxel.chunk);
						voxel.chunk.setMatrixAt(voxel.indexInChunk, new THREE.Matrix4().makeTranslation(instancedWorldSafetyOffset.x, instancedWorldSafetyOffset.y, instancedWorldSafetyOffset.z));
						voxel.chunk.instanceMatrix.needsUpdate = true;

						voxel.position = new THREE.Vector3(x, i, z);

						fullHole.push(voxel);
					}
				}
			}
		}
		const endTime = performance.now();
		console.log("conjunction check took " + (endTime - startTime) + " milliseconds");

		console.log(fullHole.length);
		if (fullHole.length > 5)
		{
			const sound = Math.floor(Math.random() * bigDropSounds.length)
			bigDropSounds[sound].rate(Math.random() + 0.75);
			bigDropSounds[sound].play();
		}

		if (USERSETTINGS.useSpriteParticles) {
			const geometry = new THREE.BufferGeometry();
			const vertexPositions = [];
			const vertexColors = [];
			const material = new THREE.PointsMaterial({
				size: 2.5,
				map: cubeSprite,
				sizeAttenuation: true
			});
			const cubeDestructionParticles = new ParticleMesh(geometry, material);
			cubeDestructionParticles.velocities = [];
			for (let i = 0; i < fullHole.length; i++) {
				const voxelData = fullHole[i];
				if (voxelData == undefined) break;
				vertexPositions.push(voxelData.position.x, voxelData.position.y, voxelData.position.z);
				const color = new THREE.Color(0xffffff);
				voxelData.chunk.getColorAt(voxelData.indexInChunk, color);
				vertexColors.push(color);
				// random velocity X,Y
				const velocityStrength = 1 / 5;
				cubeDestructionParticles.velocities.push(
					new THREE.Vector3(
						(Math.random() - 0.5) * velocityStrength,
						-(Math.random() + 0.5) * (velocityStrength * 5),
						(Math.random() - 0.5) * velocityStrength
					)
				);
			}
			geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertexPositions, 3));
			geometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors, 3));
			material.color = vertexColors[Math.floor(vertexColors.length / 2)]

			scene.add(cubeDestructionParticles);
			cubeDestructionParticles.frustumCulled = false;
			cubeDestructionParticlesSimulator.push(cubeDestructionParticles);
		}
		else {
			const wreckedMesh = new VoxelChunk(
				voxelGeometry,
				voxelMaterial,
				fullHole.length
			);
			wreckedMesh.velocities = [];
			for (let i = 0; i < fullHole.length; i++) {
				const voxelData = fullHole[i];
				if (voxelData == undefined) break;
				wreckedMesh.setMatrixAt(i, new THREE.Matrix4().makeTranslation(voxelData.x, voxelData.y, voxelData.z));
				const velocityStrength = 0.5;
				wreckedMesh.velocities.push(
					new THREE.Vector3(
						(Math.random() - 0.5) * velocityStrength,
						-(Math.random() + 0.5) * velocityStrength,
						(Math.random() - 0.5) * velocityStrength
					)
				);
				wreckedMesh.setColorAt(i, voxelData.color);
			}
			scene.add(wreckedMesh);
			wreckedMeshes.push(wreckedMesh);
		}
	}
}

// setInterval(conjunctionCheck, conjunctionCheckTimesPerSecond * 1000);

document.addEventListener('mousedown', function (e) {
	// if mouse4 click
	if (e.button == 3) {
		conjunctionCheck();
		activateExplosives();
	}
});

// create an array of random numbers
const bankLength = 10;
const randomBank = [];
for (let i = 0; i < bankLength; i++) {
	randomBank.push(Math.random());
}
var bankIterator = 0;
const rapidFloat = () => { return randomBank[bankIterator++ % bankLength]; }
const shootRay = function () {
	// RAYCAST INTO THE VOXEL FIELD
	// STEP 1: GET THE CAMERA POSITION
	// STEP 2: GET THE CAMERA DIRECTION
	// STEP 3: CALL voxelField.raycast() WITH THE CAMERA POSITION AND DIRECTION, and a step range of weaponRange
	// STEP 4: IF THE RAYCAST RETURNS A HIT, DESTROY THE VOXEL AT THAT POSITION
	// CAMERA POSITION
	const cameraPosition = new THREE.Vector3();
	camera.getWorldPosition(cameraPosition);
	cameraPosition.x = Math.round(cameraPosition.x);
	cameraPosition.y = Math.round(cameraPosition.y);
	cameraPosition.z = Math.round(cameraPosition.z);
	const cameraDirection = new THREE.Vector3();
	camera.getWorldDirection(cameraDirection);
	const intersection = voxelField.raycast(cameraPosition, cameraDirection, weaponRange);
	// Determine which voxels in chunk are to be destroyed
	if (intersection != null) {
		const currentModel = intersection.chunk;

		let destroyedVoxelsInChunk = [];

		const intersectPosition = new THREE.Vector3(
			intersection.x,
			intersection.y,
			intersection.z
		)

		const intersectedVoxelData = voxelField.get(intersectPosition.x, intersectPosition.y, intersectPosition.z);

		// for every voxel within a destroyedChunkRange of the intersection, destroy it
		for (let x = intersectPosition.x - destroyedChunkRange; x <= intersectPosition.x + destroyedChunkRange; x++) {
			for (let y = intersectPosition.y - destroyedChunkRange; y <= intersectPosition.y + destroyedChunkRange; y++) {
				for (let z = intersectPosition.z - destroyedChunkRange; z <= intersectPosition.z + destroyedChunkRange; z++) {
					const voxelPosition = new THREE.Vector3(
						x,
						y,
						z
					);

					const distanceToIntersectPos = voxelPosition.distanceTo(intersectPosition);
					// further the distance is from center, increase chance of missing
					// use percentMissedHits (0-1)
					if ((distanceToIntersectPos * percentMissedHits) < rapidFloat()) destroyedVoxelsInChunk.push(voxelPosition);
				}
			}
		}

		// 
		// ### ASSIGN PHYSICS
		// 
		// if recentlyeditedworldmodels DOES NOT HAVE currentmodel
		if (!recentlyEditedWorldModels.some(model => model.name == currentModel.name)) {
			recentlyEditedWorldModels.push(currentModel);
		}
		if (recentlyEditedWorldModels.length > maxChunksInPhysicsCache) recentlyEditedWorldModels.shift();
		generateDestroyedChunkAt(destroyedVoxelsInChunk);
	}
}

var explosives = [];
const plantExplosive = function () {

	const cameraPosition = new THREE.Vector3();
	camera.getWorldPosition(cameraPosition);
	cameraPosition.x = Math.round(cameraPosition.x);
	cameraPosition.y = Math.round(cameraPosition.y);
	cameraPosition.z = Math.round(cameraPosition.z);
	const cameraDirection = new THREE.Vector3();
	camera.getWorldDirection(cameraDirection);
	const intersection = voxelField.raycast(cameraPosition, cameraDirection, 100);
	// Determine which voxels in chunk are to be destroyed
	if (intersection != null) {
		const weaponModel = weaponModel.clone();
		weaponModel.explodeRange = destroyedChunkRange;
		weaponModel.onBeforeRender = function () { return };
		weaponModel.renderOrder = 0;
		weaponModel.scale.multiplyScalar(weaponRealWorldScaleMultiplier);
		const intersectionPosition = new THREE.Vector3(
			intersection.x,
			intersection.y,
			intersection.z
		);
		intersectionPosition.addScaledVector(cameraDirection, -2);
		weaponModel.position.copy(intersectionPosition);
		scene.add(weaponModel);
		explosives.push(weaponModel);
	}
}

const activateExplosives = function () {
	explosives.forEach(explosive => {
		const position = new THREE.Vector3();
		explosive.getWorldPosition(position);
		// round
		position.x = Math.round(position.x/* + (explosive.scale.x/2) */);
		position.y = Math.round(position.y/* + (explosive.scale.y/2) */);
		position.z = Math.round(position.z/* + (explosive.scale.z/2) */);

		const damageRange = explosive.explodeRange;
		const destroyedVoxelsInChunk = [];

		// const vizSphere = new THREE.Mesh(
		//     new THREE.SphereGeometry(damageRange/2, 8, 8),
		//     new THREE.MeshBasicMaterial({color:0xff0000, wireframe:true})
		// );
		// vizSphere.position.copy(position);
		// scene.add(vizSphere);

		for (let x = -(damageRange / 2); x <= (damageRange / 2); x++) {
			for (let y = -(damageRange / 2); y <= (damageRange / 2); y++) {
				for (let z = -(damageRange / 2); z <= (damageRange / 2); z++) {
					const voxelPosition = new THREE.Vector3(
						x + position.x,
						y + position.y,
						z + position.z
					);
					const voxel = voxelField.get(voxelPosition.x, voxelPosition.y, voxelPosition.z);
					if (voxel.value != 0) {
						const crumbleRange = 5;
						const distanceToExplosive = voxelPosition.distanceTo(position);
						if (distanceToExplosive < damageRange / 2 - crumbleRange) {
							destroyedVoxelsInChunk.push(voxelPosition);
						} else if (distanceToExplosive < damageRange / 2) {
							if (Math.random() < 0.5) destroyedVoxelsInChunk.push(voxelPosition);
						}
					}
				}
			}
		}

		scene.remove(explosive);
		explosive.geometry.dispose();

		generateDestroyedChunkAt(destroyedVoxelsInChunk, 0.05);
	});

	explosives = [];
}

render(); // calls render loop

// window resize handler
window.addEventListener('resize', () => {
	const width = window.innerWidth;
	const height = window.innerHeight;
	renderer.setSize(width, height);
	composer.setSize(width, height);
	camera.aspect = width / height;
	camera.updateProjectionMatrix();
}, false);

// DEBUG PANEL (in console)
document.addEventListener('keydown', function (e) {
	if (e.key == "p") {
		console.log("\n+==============================+\n")
		console.log("CAMERA POSITION");
		console.log(camera.position);
		console.log("draw calls #");
		console.log(renderer.info.render.calls);
		console.log("THREE SCENE");
		console.log(scene);
		console.log("instanced model index");
		console.log(instancedModelIndex);
		console.log("TRIVOXELS INDEX");
		console.log(triVoxelDroppedPieces);
		console.log("\n+==============================+\n")
	}
	if (e.key == 'e') camera.position.y += 10;
	if (e.key == 'q') camera.position.y -= 10;
	if (e.key == 'n') {
		const sRange = 250;
		for (let i = 0; i < 10; i++)
		{
			const testDummy = new NPC(
				'swat',
				'character_models/swat_idle.png',
				new THREE.Vector3(
					Math.random() * sRange - (sRange/2),
					0,
					Math.random() * sRange - (sRange/2)),
				new THREE.Vector3(
					0,
					Math.random() * Math.PI * 2,
					0),
				100 + Math.random() * 100,
				100);
		}
	}

	// stolen from stackoverflow:
	// guesses the size of an object
	if (e.key == 'z') {
		function roughSizeOfObject(object) {

			var objectList = [];
			var stack = [object];
			var bytes = 0;

			while (stack.length) {
				var value = stack.pop();

				if (typeof value === 'boolean') {
					bytes += 4;
				}
				else if (typeof value === 'string') {
					bytes += value.length * 2;
				}
				else if (typeof value === 'number') {
					bytes += 8;
				}
				else if
					(
					typeof value === 'object'
					&& objectList.indexOf(value) === -1
				) {
					objectList.push(value);

					for (var i in value) {
						if (value.hasOwnProperty(i)) {
							if (value[i] !== null) {
								stack.push(value[i]);
							}
						}
					}
				}
			}
			return bytes;
		}

		console.log('Rough size of all instancedmeshes in bytes: ');
		var total = 0;
		for (const mesh in instancedModelIndex) {
			total += roughSizeOfObject(instancedModelIndex[mesh]);
		}
		console.log(total);
	}
});

setHelpText("Loading Map...");
</script>

	<div id="help-text">Loading . . .</div>
	<script src="./renderer.js"></script>
</body>

</html>