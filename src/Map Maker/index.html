<!-- HTML layout with a left side panel, top navigation bar, right side panel, and bottom panel -->
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Loading...</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
	<script type="importmap">
			{
				"imports": {
					"three": "../opensource/threejs/build/three.module.js",
					"three/addons/": "../opensource/threejs/examples/jsm/",
					"three/nodes": "../opensource/threejs/examples/jsm/nodes/Nodes.js"
				}
			}
	</script>
</head>

<body>
    <!-- <div id="target" style="position: absolute; top:0; left:0; z-index: 2000; background: red;">a</div> -->
    <!-- Right Click Context Menu -->
    <div id="right-click-menu">
        <li>Option 1</li>
        <li>Option 2</li>
        <li>Option 3</li>
        <li>Option 4</li>
        <li>Option 5</li>
    </div>

    <div class="container">
        <div id="top-panel" class="panel">
            <div id="top-panel-bar">
                <span class="top-panel-option" id="save-button">
                    Save
                </span>
                <span class="top-panel-option" id="import-button">
                    Open
                </span>
                <span class="top-panel-option">
                    Help
                </span>
                <span class="top-panel-option" style="color:#494949; pointer-events: none;">
                    |
                </span>
                <span class="top-panel-option" id="export-button">
                    Export
                </span>
                <div class="top-panel-option" style="width: 59%; opacity: 0">a</div>
                <span class="top-panel-option nohover"
                    style="white-space: nowrap; text-align: right; padding-right: 15px;">
                    <a href="game.html">Launch Runner</a>
                </span>
            </div>
        </div>
        <div id="left-panel" class="panel">
            <h1>Hierarchy</h1>
            <span id="object-counter">0</span><span id="object-counter-label"> total objects</span>
            <ul id="scene-objects-list"></ul>
        </div>
        <div id="right-panel" class="panel">
            <h1>Inspector</h1>
            <p id="selection-name">nothing selected</p>
            <div id="object-inspector-elements"></div>
        </div>
        <div id="bottom-panel" class="panel">
            <div class="resize-unflip">
                <h1>Map Settings</h1>
                <!-- Ground Settings -->
                <h2>Ground</h2>
                <div class="settings-group">
                    <h3>Sky Color</h3>
                    <input type="color" id="ambient-color">
                </div>
                <div class="settings-group">
                    <h3>Next Level URL</h3>
                    <input type="text" id="next-level-url">
                </div>
            </div>
        </div>

        <!-- Editor Window -->
        <div id="center-panel" class="panel">
            <h1>Loading . . .</h1>
        </div>

        <div class="tooltip">Thank you for playing my game and making mods :)</div>
    </div>

    <script type="module">
// ### IMPORTANT METADATA
const editorVersion = "0.1.0"

// ### TOOLTIPS
const sendTooltip = function(tip) {
    // create a "tip" element
    const tipElement = document.createElement("div");
    tipElement.classList.add("tooltip");
    tipElement.innerHTML = tip;
    document.body.appendChild(tipElement);
}

//  ### IMPORTS
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { TransformControls } from 'three/addons/controls/TransformControls.js';
import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';
import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';

// ### MOUSE POSITION
const globalMousePosition = {
    clientX: 0,
    clientY: 0
}

document.addEventListener('mousemove', function (event) {
    globalMousePosition.clientX = event.clientX;
    globalMousePosition.clientY = event.clientY;
});

// ### CANVAS INITIALIZATION
const editorWindow = document.querySelector("#center-panel");
editorWindow.innerHTML = "";
const canvas = document.createElement("canvas");
canvas.id = "editor-canvas";
canvas.width = editorWindow.clientWidth;
canvas.height = editorWindow.clientHeight;
editorWindow.appendChild(canvas);


// ### THREE.JS RENDERER INITIALIZATION
const DEFAULTOBJECTS = [];
const MAPOBJECTS = [];
var scene = new THREE.Scene();
scene.name = "New Scene"
const camera = new THREE.PerspectiveCamera(80, canvas.width / canvas.height, 1, 5000);
camera.position.x = -276.5656251980899;
camera.position.y = 225.36512419213917;
camera.position.z = 274.28691501840778;
camera.rotation.x = -0.7733129332359928;
camera.rotation.y = -0.6160013614421702;
camera.rotation.z = -0.5135108191734854;
DEFAULTOBJECTS.push(camera);

// LIGHTING
const ambientLight = new THREE.AmbientLight(0xffffff, 1);
scene.add(ambientLight);
DEFAULTOBJECTS.push(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 0.75);
directionalLight.position.set(1, 1, 1);
scene.add(directionalLight);
DEFAULTOBJECTS.push(directionalLight);
const opposingDirectionalLight = new THREE.DirectionalLight(0xffffff, 0.25);
opposingDirectionalLight.position.set(-1, -1, -1);
scene.add(opposingDirectionalLight);
DEFAULTOBJECTS.push(opposingDirectionalLight);

// Human for Scale
const human = new THREE.Mesh(
    new THREE.PlaneGeometry(1, 1),
    new THREE.MeshBasicMaterial({
        map: new THREE.TextureLoader().load("../img/humanforscale.png"),
        transparent: true,
        side: THREE.DoubleSide,
    })
);
human.type = "human";
human.material.map.magFilter = THREE.NearestFilter;
human.material.map.minFilter = THREE.NearestFilter;
human.scale.set(11.10625, 40);
human.position.y = human.scale.y/2;
const playerSpawn = new THREE.Group();
playerSpawn.add(human);
scene.add(playerSpawn);

// Renderer
THREE.ColorManagement.legacyMode = false
const renderer = new THREE.WebGLRenderer({
	antialias: true,
    canvas: canvas
});
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setPixelRatio(window.devicePixelRatio);
// THREE.ColorManagement.legacyMode = false
// renderer.toneMapping = THREE.ACESFilmicToneMapping // currently bugged out? (r152 see bug report from 2021 going back a few versions, im not smart enough to understand how to fix it... color math is so beyond me)
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.logarithmicDepthBuffer = true;
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setClearColor(0x1e2021, 1);

// MATERIALS
const cutawayMaterial = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    transparent: true,
    opacity: 0.5,
    side: THREE.DoubleSide,
    depthTest: false
});
// EFFECTS
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const outlinePass = new OutlinePass(new THREE.Vector2(canvas.width, canvas.height), scene, camera);
outlinePass.edgeStrength = 3;
composer.addPass(outlinePass);
const fxaaPass = new ShaderPass(FXAAShader);
fxaaPass.uniforms['resolution'].value.set(1 / canvas.width, 1 / canvas.height);
composer.addPass(fxaaPass);
const sao = new SAOPass(scene, camera, true, true);
sao.params.saoScale = 9.5;
sao.params.saoBias = 0.5;
sao.params.saoIntensity = 0.0007;
sao.params.saoKernelRadius = 100;
composer.addPass(sao);
const controls = new OrbitControls(camera, canvas);
controls.name = "OrbitControls";
// controls.panSpeed = controls.rotateSpeed = 0.5;
controls.dollyOut = function(){
    this.object.position.z -= 25;
}
controls.dollyIn = function(){
    this.object.position.z += 25;
}
DEFAULTOBJECTS.push(controls);
const adjustCanvasSize = function () {
    canvas.width = editorWindow.clientWidth;
    canvas.height = editorWindow.clientHeight;
    camera.aspect = canvas.width / canvas.height;
    camera.updateProjectionMatrix();
    renderer.setSize(canvas.width, canvas.height);
    composer.setSize(canvas.width, canvas.height);
    fxaaPass.uniforms['resolution'].value.set(1 / canvas.width, 1 / canvas.height);
};

// ### EVENT LISTENERS
window.addEventListener('resize', adjustCanvasSize);

// ### ANIMATION LOOP
let filePath = "NO FILE LOADED";
const clock = new THREE.Clock();
const animate = function () {
    const delta = clock.getDelta();
    const fps = 1 / delta;
    document.title = "Wreck Engine Tools - Map Maker [v" + editorVersion + " @ " + fps.toFixed(0) + " FPS] - " + filePath;
    if (selectedObjects) {
        outlinePass.selectedObjects = selectedObjects.children;
    }

    requestAnimationFrame(animate);
    controls.update();
    composer.render();
};
animate();

//  ### SIMPLE FUNCTIONS

const updateRightPanel = function (item, clear=false) {
    document.querySelector("#selection-name").innerHTML = item.name;

    // for each property in the object, create an input field in #object-inspector-elements
    const inspector = document.querySelector("#object-inspector-elements");
    inspector.innerHTML = "";

    if (clear) return;

    if (item.isObject3D == true) {
        // Position (X, Y, Z) in a row
        const position = document.createElement("div");
        position.classList.add("inspector-element");
        position.innerHTML = "<h3>Position</h3>";
        const positionX = document.createElement("input");
        positionX.type = "number";
        positionX.value = selectedObjects.position.x;
        positionX.style.width = "75px";
        positionX.addEventListener("input", function () {
            positionX.value = positionX.value.replace(/\D/g,'')
            selectedObjects.position.x = parseInt(positionX.value);
        });
        const positionY = document.createElement("input");
        positionY.type = "number";
        positionY.value = selectedObjects.position.y;
        positionY.style.width = "75px";
        positionY.addEventListener("input", function () {
            positionY.value = positionY.value.replace(/\D/g,'')
            selectedObjects.position.y = parseInt(positionY.value);
        });
        const positionZ = document.createElement("input");
        positionZ.type = "number";
        positionZ.value = selectedObjects.position.z;
        positionZ.style.width = "75px";
        positionZ.addEventListener("input", function () {
            positionZ.value = positionZ.value.replace(/\D/g,'')
            selectedObjects.position.z = parseInt(positionZ.value);
        });
        position.appendChild(positionX);
        position.appendChild(positionY);
        position.appendChild(positionZ);
        inspector.appendChild(position);

        // Scale (X, Y, Z) in a row
        const scale = document.createElement("div");
        scale.classList.add("inspector-element");
        scale.innerHTML = "<h3>Scale</h3>";
        const scaleX = document.createElement("input");
        scaleX.type = "number";
        scaleX.value = selectedObjects.scale.x;
        scaleX.style.width = "75px";
        scaleX.addEventListener("input", function () {
            selectedObjects.scale.x = scaleX.value;
        });
        const scaleY = document.createElement("input");
        scaleY.type = "number";
        scaleY.value = selectedObjects.scale.y;
        scaleY.style.width = "75px";
        scaleY.addEventListener("input", function () {
            selectedObjects.scale.y = scaleY.value;
        });
        const scaleZ = document.createElement("input");
        scaleZ.type = "number";
        scaleZ.value = selectedObjects.scale.z;
        scaleZ.style.width = "75px";
        scaleZ.addEventListener("input", function () {
            selectedObjects.scale.z = scaleZ.value;
        });

        // isLight
        const isLight = document.createElement("div");
        isLight.classList.add("inspector-element");
        isLight.innerHTML = "<h3>Is Light</h3>";
        const isLightInput = document.createElement("input");
        isLightInput.type = "checkbox";
        isLightInput.checked = item.userData.isLight;
        isLightInput.addEventListener("input", function () {
            selectedObjects.children.forEach(childObject => {
                childObject.userData.isLight = isLightInput.checked;
            });
        });
        isLight.appendChild(isLightInput);
        inspector.appendChild(isLight);
        // light brightness
        const lightBrightness = document.createElement("div");
        lightBrightness.classList.add("inspector-element");
        lightBrightness.innerHTML = "<h3>Brightness</h3>";
        const lightBrightnessInput = document.createElement("input");
        lightBrightnessInput.type = "number";
        lightBrightnessInput.value = item.userData.lightBrightness;
        lightBrightnessInput.addEventListener("input", function () {
            selectedObjects.children.forEach(childObject => {
                childObject.userData.lightBrightness = lightBrightnessInput.value;
            });
        });
        lightBrightness.appendChild(lightBrightnessInput);
        inspector.appendChild(lightBrightness);

        // interactionEvent (if it has one)
        if (item.userData.interactionEvent != undefined) {
            const interactionEvent = document.createElement("div");
            interactionEvent.classList.add("inspector-element");
            interactionEvent.innerHTML = "<h3>Interaction Event</h3>";
            const interactionEventInput = document.createElement("input");
            interactionEventInput.type = "text";
            interactionEventInput.value = item.userData.interactionEvent;
            interactionEventInput.addEventListener("input", function () {
                selectedObjects.children.forEach(childObject => {
                    childObject.userData.interactionEvent = interactionEventInput.value;
                });
            });
            interactionEvent.appendChild(interactionEventInput);
            inspector.appendChild(interactionEvent);
        }

        // weapon pickup (if it has one)
        if (item.userData.weaponType != undefined) {
            const weaponType = document.createElement("div");
            weaponType.classList.add("inspector-element");
            weaponType.innerHTML = "<h3>Weapon Pickup Type</h3><br/><h6>Ex. <code>SMG</code>, <code>DUALUZI</code>, <code>PISTOL</code> </h6>";
            const weaponTypeInput = document.createElement("input");
            weaponTypeInput.type = "text";
            weaponTypeInput.value = item.userData.weaponType;
            weaponTypeInput.addEventListener("input", function () {
                selectedObjects.children.forEach(childObject => {
                    childObject.userData.weaponType = weaponTypeInput.value;
                });
            });
            weaponType.appendChild(weaponTypeInput);
            inspector.appendChild(weaponType);
        }

        // finalize
        scale.appendChild(scaleX);
        scale.appendChild(scaleY);
        scale.appendChild(scaleZ);
        inspector.appendChild(scale);
    }
    if (item.userData.isEnemyNPC == true)
    {
        // [USERDATA] Movement Speed
        // Set the default to 10
        if (item.userData.movementSpeed == undefined) {
            item.userData.movementSpeed = 1;
        }
        const movementSpeed = document.createElement("div");
        movementSpeed.classList.add("inspector-element");
        movementSpeed.innerHTML = "<h3>Movement Speed</h3>";
        const movementSpeedInput = document.createElement("input");
        movementSpeedInput.type = "number";
        movementSpeedInput.value = item.userData.movementSpeed;
        movementSpeedInput.addEventListener("input", function () {
            selectedObjects.children.forEach(childObject => {
                childObject.userData.movementSpeed = movementSpeedInput.value;
            });
        });
        movementSpeed.appendChild(movementSpeedInput);
        inspector.appendChild(movementSpeed);
        // [USERDATA] Enemy Behaviour (Passive or Normal)
        // Set the default to Normal
        if (item.userData.enemyBehaviour == undefined) {
            item.userData.enemyBehaviour = "normal";
        }
        const enemyBehaviour = document.createElement("div");
        enemyBehaviour.classList.add("inspector-element");
        enemyBehaviour.innerHTML = "<h3>Enemy Behaviour</h3>";
        const enemyBehaviourInput = document.createElement("select");
        enemyBehaviourInput.innerHTML = "<option value='normal'>Normal</option><option value='passive'>Passive</option>";
        enemyBehaviourInput.value = item.userData.enemyBehaviour;
        enemyBehaviourInput.addEventListener("input", function () {
            selectedObjects.children.forEach(childObject => {
                childObject.userData.enemyBehaviour = enemyBehaviourInput.value;
            });
        });
        enemyBehaviour.appendChild(enemyBehaviourInput);
        inspector.appendChild(enemyBehaviour);
        // [USERDATA] Enemy Health
        // Set the default to 100
        if (item.userData.enemyHealth == undefined) {
            item.userData.enemyHealth = 100;
        }
        const enemyHealth = document.createElement("div");
        enemyHealth.classList.add("inspector-element");
        enemyHealth.innerHTML = "<h3>Enemy Health</h3>";
        const enemyHealthInput = document.createElement("input");
        enemyHealthInput.type = "number";
        enemyHealthInput.value = item.userData.enemyHealth;
        enemyHealthInput.addEventListener("input", function () {
            selectedObjects.children.forEach(childObject => {
                childObject.userData.enemyHealth = enemyHealthInput.value;
            });
        });
        enemyHealth.appendChild(enemyHealthInput);
        inspector.appendChild(enemyHealth);
        // [USERDATA] Enemy Type (Swat, Thug, )
        // Set the default to Swat
        if (item.userData.enemyType == undefined) {
            item.userData.enemyType = "swat";
        }
        const enemyType = document.createElement("div");
        enemyType.classList.add("inspector-element");
        enemyType.innerHTML = "<h3>Enemy Type</h3>";
        const enemyTypeInput = document.createElement("select");
        enemyTypeInput.innerHTML = "<option value='swat'>Swat</option><option value='thug'>Thug</option>";
        enemyTypeInput.value = item.userData.enemyType;
        enemyTypeInput.addEventListener("input", function () {
            selectedObjects.children.forEach(childObject => {
                childObject.userData.enemyType = enemyTypeInput.value;
            });
        });
        enemyType.appendChild(enemyTypeInput);
        inspector.appendChild(enemyType);
    }
    // For each material (if any) - this only applies to 3D objects in the world, so it can have properties such as cutaway as well
    if (item.material != undefined && item.userData.isEnemyNPC != true) {
        // for each material
        // Material
        const material = document.createElement("div");
        material.classList.add("inspector-element");
        material.innerHTML = "<h3>Material</h3>";
        
        const addMaterial = function(filename) {
            const newMaterial = document.createElement("button");
            newMaterial.innerHTML = filename;
            newMaterial.addEventListener("click", function () {
                selectedObjects.children.forEach(childObject => {
                    childObject.material = new THREE.MeshBasicMaterial({
                        color: item.material.color,
                        roughness: 0.9,
                        metalness: 0.1,
                        map: new THREE.TextureLoader().load('../textures/' + filename + '.png')
                    });
        		    childObject.material.map.encoding = THREE.sRGBEncoding;
                    childObject.material.map.magFilter = THREE.NearestFilter;
                    childObject.material.map.wrapS = THREE.RepeatWrapping;
                    childObject.material.map.wrapT = THREE.RepeatWrapping;
                    childObject.userData.materialType = filename;
                    realignTexture(childObject, childObject.scale.x, childObject.scale.z);
                });
            });
            material.appendChild(newMaterial);
        }

        addMaterial('rough')
        addMaterial('smooth')
        addMaterial('tile')
        addMaterial('ceilingtile')
        addMaterial('wood')
        addMaterial('woodpanel')
        addMaterial('bricks')
        addMaterial('cobblestone')
        addMaterial('wallpaper')
        addMaterial('abstract-lines')
        addMaterial('pizza')
        addMaterial('debug')

        // global color override
        const materialColor = document.createElement("input");
        materialColor.type = "color";
        materialColor.value = "#" + item.material.color.getHexString();
        materialColor.addEventListener("input", function () {
            selectedObjects.children.forEach(childObject => {
                childObject.material.color.set(materialColor.value);
            });
        });

        material.appendChild(materialColor);
        inspector.appendChild(material);

        // is cutaway (boolean)
        const cutaway = document.createElement("div");
        cutaway.classList.add("inspector-element");
        cutaway.innerHTML = "<h3>Act As Cutaway</h3>";
        const cutawayInput = document.createElement("input");
        cutawayInput.type = "checkbox";
        cutawayInput.checked = item.userData.isCutaway;
        cutawayInput.addEventListener("input", function () {
            item.userData.isCutaway = cutawayInput.checked;
            if (item.userData.isCutaway) {
                item.material = cutawayMaterial;
            }
        });
        cutaway.appendChild(cutawayInput);
        inspector.appendChild(cutaway);
    }
    if (item.userData.isGroundFloor) {
        const groundFloorEnabled = document.createElement("div");
        groundFloorEnabled.classList.add("inspector-element");
        groundFloorEnabled.innerHTML = "<h3>Enabled</h3>";
        const groundFloorEnabledInput = document.createElement("input");
        groundFloorEnabledInput.type = "checkbox";
        groundFloorEnabledInput.checked = item.userData.isGroundFloor;
        groundFloorEnabledInput.addEventListener("input", function () {
            mapHasGround = groundFloorEnabledInput.checked;
            groundFloor.visible = mapHasGround;
        });
    }
    // Camera (only one in scene)
    if (item.isCamera == true) {
        // [USERDATA] Movement Speed
        // Set the default to 10
        if (item.userData.movementSpeed == undefined) {
            item.userData.movementSpeed = 1;
        }
        const movementSpeed = document.createElement("div");
        movementSpeed.classList.add("inspector-element");
        movementSpeed.innerHTML = "<h3>Movement Speed</h3>";
        const movementSpeedInput = document.createElement("input");
        movementSpeedInput.type = "number";
        movementSpeedInput.value = item.userData.movementSpeed;
        movementSpeedInput.addEventListener("input", function () {
            item.userData.movementSpeed = movementSpeedInput.value;
        });
        movementSpeed.appendChild(movementSpeedInput);
        inspector.appendChild(movementSpeed);
    }
}
const randomColor = function () { return new THREE.Color(0xffffff * Math.random()); }
var transformControls = new TransformControls(camera, canvas);
transformControls.name = "TransformControls";
transformControls.setRotationSnap(THREE.MathUtils.degToRad(45));
transformControls.setTranslationSnap(1);
// transformControls.setScaleSnap(1);
transformControls.userData.existInGame = false;
var selectedObjects = new THREE.Group();
scene.add(selectedObjects);
transformControls.attach(selectedObjects);
document.body.addEventListener('keydown', function (event) {
    if (event.key == "s") {
        console.log(transformControls.scale.x, transformControls.scale.y, transformControls.scale.z);
        console.log(selectedObjects.scale.x, selectedObjects.scale.y, selectedObjects.scale.z);
    }
    if (event.key == "f")
    {
        controls.target.copy(selectedObjects.position);
    }
});
var retachAvailable = true;
transformControls.size = 1.25;
DEFAULTOBJECTS.push(transformControls);
scene.add(transformControls);
var lastAttachedObject;
const objectsUnderground = [];
// load ../img/errorTex as errorTex
const realignTexture = function(sceneObject, scaleX, scaleZ) {
    if (!sceneObject.material.map) return;
    scaleX = Math.abs(scaleX);
    scaleZ = Math.abs(scaleZ);
    const squareChunkSize = 64;
    sceneObject.material.map.repeat.x = 4//scaleX / (squareChunkSize/2);
    sceneObject.material.map.repeat.y = 4//scaleZ / (squareChunkSize/2);
    sceneObject.material.map.needsUpdate = true;
    console.log("Realigned texture with dimensions: " + sceneObject.material.map.repeat.x + "," + sceneObject.material.map.repeat.y);
}
const errorTex = new THREE.TextureLoader().load("../img/errorTex.png");
const clamp = function(val, min, max) {
    return Math.min(Math.max(val, min), max);
}
const shiftUp = function(obj) {
    const boundingBox = new THREE.Box3().setFromObject(obj);
    if (boundingBox.min.y < -1) {
        obj.position.y += Math.abs(boundingBox.min.y);
    }
}

const multipleCheck = function(n, d) { return Math.round(n / d) * d }

// On any update to transform controls ...
transformControls.addEventListener('dragging-changed', function (event) {
    controls.enabled = !event.value;
    retachAvailable = !event.value;

    if (event.value == false) {

        if (lastAttachedObject != undefined) {
            // Cache the selected objects ...
            const tempSelObjs = Array.from(selectedObjects.children);
            clearSelectedObjects();
            tempSelObjs.forEach(child => {
                // if the selected objects are underground, move them up
                shiftUp(child);
                // Adjust scales for walls, floors and details
                if (child.userData.isEnemyNPC == false)
                {
                    switch (child.userData.gameObjectType)
                    {
                        default:
                            console.error("Failed to process transform for type: " + child.userData.gameObjectType);
                            break;
                        case "WeaponPickup":
                            child.scale.set(1,1,1);
                            break;
                        case "Wall":
                            if (child.userData.isRotated == false) {
                                child.scale.x = clamp(multipleCheck(child.scale.x, 64), 64, Infinity);
                                child.scale.y = 64;
                                child.scale.z = 2;
                            }
                            else
                            {
                                child.scale.x = 2;
                                child.scale.y = 64;
                                child.scale.z = clamp(multipleCheck(child.scale.z, 64), 64, Infinity);
                            }

                            child.position.x = multipleCheck(child.position.x, 32);
                            child.position.y = multipleCheck(child.position.y, 32);
                            child.position.z = multipleCheck(child.position.z, 32);
                            break;
                        case "Floor":
                            child.scale.x = clamp(multipleCheck(child.scale.x, 64), 64, Infinity);
                            child.scale.y = 2;
                            child.scale.z = clamp(multipleCheck(child.scale.z, 64), 64, Infinity);

                            child.position.x = multipleCheck(child.position.x, 32);
                            child.position.y = multipleCheck(child.position.y, 32);
                            child.position.z = multipleCheck(child.position.z, 32);
                            break;
                        case "Detail":
                            if (child.scale.x < 1) child.scale.x = 1;
                            if (child.scale.y < 1) child.scale.y = 1;
                            if (child.scale.z < 1) child.scale.z = 1;
                            child.scale.round();
                            break;
                    }

                }
                // round the position to the nearest whole number
                child.position.x = Math.round(child.position.x);
                child.position.y = Math.round(child.position.y);
                child.position.z = Math.round(child.position.z);
                // reattach to the controls (to keep it all seamless)
                // attachHandles(child, true);
            });
            // round the position of the selectedObjects to the nearest whole number
            tempSelObjs.forEach(sceneObject => {
                realignTexture(sceneObject, selectedObjects.scale.x, selectedObjects.scale.z);
            });
        }

        updateRightPanel(lastAttachedObject);
    }

});

// ### UPDATING HIERARCHY PANEL ###
const updateLeftPanel = function () {
    const list = document.querySelector("#scene-objects-list");
    list.innerHTML = "";
    const sceneObjects = [];
    for (let i = 0; i < scene.children.length; i++) {
        sceneObjects.push(scene.children[i]);
    }
    for (let i = 0; i < sceneObjects.length; i++) {
        sceneObjects[i].updateMatrixWorld();
        if (!sceneObjects[i].userData.existInGame) continue;
        if (sceneObjects[i].userData.existInGame != false) {
            const item = document.createElement("li");
            item.innerHTML = sceneObjects[i].name;

            list.appendChild(item);

            item.addEventListener("click", function () {
                // add transform controls to the item
                var sceneObject;
                for (let i = 0; i < sceneObjects.length; i++) {
                    if (sceneObjects[i].name == item.innerHTML) {
                        sceneObject = sceneObjects[i];
                        break;
                    }
                }
                attachHandles(sceneObject);
                item.classList.add("active");
                for (let i = 0; i < list.children.length; i++) {
                    if (list.children[i] !== item) {
                        list.children[i].classList.remove("active");
                    }
                }
            });
        }
    }

    // for each element in the scene ,if it is a lighthelper and has no valid 'light' object assigned, remove it completely and run updateLeftPanel again
    for (let i = 0; i < scene.children.length; i++) {
        if (scene.children[i].isLightHelper) {
            if (scene.children[i].light == undefined) {
                scene.remove(scene.children[i]);
                updateLeftPanel();
            }
        }
    }
}
const clearSelectedObjects = function (skipUpdate=false) {
    transformControls.visible = false;
    for (let i = 0; i < selectedObjects.children.length; i++) {
        const child = selectedObjects.children[i];
        // get world pos
        const newPos = new THREE.Vector3();
        newPos.setFromMatrixPosition(child.matrixWorld);
        // get world scale
        const newScale = new THREE.Vector3();
        newScale.setFromMatrixScale(child.matrixWorld);
        // get world rotation
        const newRot = new THREE.Euler();
        newRot.setFromRotationMatrix(child.matrixWorld);

        child.parent.remove(child);
        scene.add(child);
        child.position.set(newPos.x, newPos.y, newPos.z);
        child.scale.set(newScale.x, newScale.y, newScale.z);
        child.rotation.set(newRot.x, newRot.y, newRot.z);
        clearSelectedObjects();
    }
    if (!skipUpdate) updateLeftPanel();
}
clearSelectedObjects();
const removeFromSelection = function (item) {
    // do clearSelectedObjects() and then add back all the items except the one we want to remove
    const oldSelectedObjects = Array.from(selectedObjects.children);
    clearSelectedObjects();
    oldSelectedObjects.forEach(oldSelectedObject => {
        if (oldSelectedObject !== item) {
            attachHandles(oldSelectedObject);
        }
    });
}

const removeHandles = function(item) {
    const tempSelObjs = Array.from(selectedObjects.children);
    clearSelectedObjects();
    tempSelObjs.forEach(selectedObject => {
        if (selectedObject !== item) {
            attachHandles(selectedObject);
        }
    });
    if (selectedObjects.children.length == 0) {
        selectedObjects.scale.set(1, 1, 1);
    }
}

const attachHandles = function (item, dontResetSelections=false, skipUpdate=false) {
    // bug fix for double-click attach:
    if (!retachAvailable) return;
    // make sure we dont select the ground floor
    if (item.userData.isGroundFloor) return;
    // if we already have it selected, forget about it!
    if (selectedObjects.children.includes(item)) {
        // remove the item from the selection
        removeFromSelection(item);
        // if we have nothing selected, hide the transform controls
        if (selectedObjects.children.length == 0) {
            transformControls.visible = false;
        }
        return;
    }
    // if we are holding shift, add to the selection
    if (isHoldingShift == false && dontResetSelections == false) {
        clearSelectedObjects(skipUpdate);
    }

    const cacheSelectedObjects = [];
    selectedObjects.children.forEach(child => {
        cacheSelectedObjects.push(child);
    });
    cacheSelectedObjects.push(item);
    clearSelectedObjects(skipUpdate);
    // selectedObjects.scale.copy(item.scale);
    selectedObjects.position.copy(item.position);

    cacheSelectedObjects.forEach(child => {
        selectedObjects.attach(child);
    });

    lastAttachedObject = item;
    transformControls.visible = true;

    // transformControls.children.forEach(child => {
    //     child.position.set(itemWorldPos.x, itemWorldPos.y, itemWorldPos.z);
    // });

    if (!skipUpdate) updateRightPanel(item);

}
const addToScene = function (item) {
    scene.add(item);
    document.querySelector("#object-counter").innerHTML = parseInt(document.querySelector("#object-counter").innerHTML) + 1;
    if (document.querySelector("#object-counter").innerHTML == 1) document.querySelector("#object-counter-label").innerHTML = " total object";
    else document.querySelector("#object-counter-label").innerHTML = " total objects";

    const list = document.querySelector("#scene-objects-list");

    updateLeftPanel();
}
const groundFloor = new THREE.Mesh(
    new THREE.BoxGeometry(1, 1, 1),
    new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.DoubleSide })
);
const ambientColor = new THREE.Color();
document.querySelector("#ambient-color").addEventListener("input", function (e) { ambientColor.set(e.target.value); });
let nextLevelURL = "";
document.querySelector("#next-level-url").addEventListener("input", function (e) { nextLevelURL = e.target.value; });
groundFloor.scale.set(100000, 100000, 1);
groundFloor.visible = false;
groundFloor.name = "Ground Floor";
groundFloor.userData.doNotVoxelize = true;
groundFloor.userData.cannotBeRemoved = true;
groundFloor.userData.isGroundFloor = true;
groundFloor.rotation.x = Math.PI / 2;
groundFloor.position.y = -1;
DEFAULTOBJECTS.push(groundFloor);
addToScene(groundFloor);
let cameraHelper;
const removeFromScene = function (item) {
    if (item.userData.cannotBeRemoved == true) return;
    // if the item is of type light, scan the scene for any helpers for it
    if (item.isLight == true) {
        for (let i = 0; i < scene.children.length; i++) {
            const thisObj = scene.children[i];
            if (thisObj.light != undefined && thisObj.light == item) {
                thisObj.parent.remove(thisObj);
            }
        }
    }
    // if transformControls is on it
    // remove the item
    item.parent.remove(item);
    document.querySelector("#object-counter").innerHTML = parseInt(document.querySelector("#object-counter").innerHTML) - 1;
    if (document.querySelector("#object-counter").innerHTML == 1) document.querySelector("#object-counter-label").innerHTML = " object";
    else document.querySelector("#object-counter-label").innerHTML = " total objects";

    updateLeftPanel();

    // if it's in MAPOBJECTS, remove it
    for (let i = 0; i < MAPOBJECTS.length; i++) {
        if (MAPOBJECTS[i] == item) {
            MAPOBJECTS.splice(i, 1);
        }
    }
}
var centerPanelIsFullScreen = false;
var isHoldingShift = false;
document.body.addEventListener("keyup", function (event) {
    if (event.key == "Shift") {
        isHoldingShift = false;
    }
});
document.body.addEventListener('keydown', function (event) {
    // if press 'del' and there is an object selected, remove it
    if (event.key == "Delete" && transformControls.object != undefined) {
        selectedObjects.children.forEach(object => {
            removeFromScene(object);
        });
        clearSelectedObjects();
    }
    if (event.key == "Shift") {
        isHoldingShift = true;
    }
    // if "escape" hide context menu
    if (event.key == "Escape") {
        document.querySelector("#right-click-menu").style.display = "none";
    }
    if (transformControls.object != undefined) {
        switch (event.key) {
            case 'w':
                transformControls.setMode("translate");
                break;
            case 'r':
                // swap X and Z scale of all selected objects
                selectedObjects.children.forEach(childObject => {
                    if (childObject.userData.isEnemyNPC == true)
                    {
                        childObject.userData.rotationIntervals += 1;
                        childObject.rotation.z = (Math.PI / 4) * childObject.userData.rotationIntervals;
                    }
                    else
                    {
                        removeHandles(childObject);
                        const temp = childObject.scale.x;
                        childObject.scale.x = childObject.scale.z;
                        childObject.scale.z = temp;
                        attachHandles(childObject);

                        if (childObject.userData.gameObjectType == "Wall") {
                            childObject.userData.isRotated = !childObject.userData.isRotated;
                        }
                    }
                });
                break;
            case 't':
                transformControls.setMode("scale");
                break;
        }
    }
    // CTRL Commands
    if (event.ctrlKey) {
        switch (event.key) {
            case 'z':
                undo();
                break;
            case 'y':
                redo();
                break;
            case 'd':
                // prevent browser bookmark
                event.preventDefault();
                // if there is a selected object, duplicate it
                if (transformControls.object != undefined) {
                    const oldSelectedObjects = Array.from(selectedObjects.children);
                    clearSelectedObjects();
                    oldSelectedObjects.forEach(old => {
                        const clone = old.clone();
                        clone.name += " (clone " + Math.floor(Math.random() * 1000) + ")";
                        // clone the materials too
                        if (clone.material != undefined) {
                            if (Array.isArray(clone.material)) {
                                for (let i = 0; i < clone.material.length; i++) {
                                    clone.material[i] = clone.material[i].clone();
                                }
                            }
                            else {
                                clone.material = clone.material.clone();
                            }
                        }
                        // also copy the userdata from the old object
                        clone.userData.isLight = old.userData.isLight;
                        clone.userData.isEnemyNPC = old.userData.isEnemyNPC;
                        clone.userData.lightBrightness = old.userData.lightBrightness;
                        clone.userData.isCutaway = old.userData.isCutaway;
                        clone.userData.existInGame = old.userData.existInGame;
                        clone.userData.materialType = old.userData.materialType;

                        addToScene(clone);
                        attachHandles(clone, true);
                        MAPOBJECTS.push(clone);
                    });
                }
                break;
            case 'a':
                if (event.altKey)
                {
                    if (transformControls.object != undefined) {
                        // select all objects
                        clearSelectedObjects();
                        for (let i = 0; i < MAPOBJECTS.length; i++) {
                            const thisObj = MAPOBJECTS[i];
                            if (thisObj.userData.existInGame == true) {
                                attachHandles(thisObj, true, true);
                            }
                        }
                    }
                }
                else
                {
                    sendTooltip("To select all world objects, click <code>CTRL + ALT + A</code>")
                }
                break;
            case 'w':
                // prevent default browser behavior
                event.preventDefault();
                break;
            case 'r':
                // prevent default browser behavior
                event.preventDefault();
                break;
            case 's':
                // prevent default browser behavior
                event.preventDefault();
                saveProject();
                break;
        }
    }
    // Shift Commands
    if (event.shiftKey) {
        switch (event.key) {
            default:
                break;
            case ' ':
                console.log(centerPanelIsFullScreen);
                // make the center panel fill the entire screen (EXCEPT the top bar paneL)
                if (centerPanelIsFullScreen == false) {
                    // style the center panel to fill
                    document.querySelector("#center-panel").style.gridRow = "1 / 5";
                    document.querySelector("#center-panel").style.gridColumn = "1 / 5";
                    document.querySelector("#center-panel").style.zIndex = "100";
                    centerPanelIsFullScreen = true;
                }
                else {
                    document.querySelector("#center-panel").style.gridRow = "2 / 3";
                    document.querySelector("#center-panel").style.gridColumn = "2 / 3";
                    document.querySelector("#center-panel").style.zIndex = "0";
                    centerPanelIsFullScreen = false;
                }
                adjustCanvasSize();
                break;
            case 'A':
                // prevent default browser behavior
                event.preventDefault();
                // invoke context menu
                invokeContextMenu();
                break;
        }
    }
});

const createEnemyNPC = function(position, rotationIntervals) {
    console.log(rotationIntervals);
    const enemyNPC = new THREE.Mesh(
        new THREE.ConeGeometry(5,15,3),
        new THREE.MeshBasicMaterial({
            color: 0xff0000,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.75
        })
    );
    enemyNPC.rotation.set(Math.PI/2, 0, rotationIntervals * Math.PI / 4);
    enemyNPC.position.copy(position);
    enemyNPC.userData.existInGame = true;
    enemyNPC.userData.isEnemyNPC = true;
    enemyNPC.userData.rotationIntervals = rotationIntervals;
    enemyNPC.userData.isLight = false;
    enemyNPC.userData.gameObjectType = "EnemyNPC"

    enemyNPC.name = "Enemy NPC - " + Math.floor(Math.random() * 1000);
    addToScene(enemyNPC);
    MAPOBJECTS.push(enemyNPC);
    return enemyNPC;
}

const createWeaponPickup = function(position, weaponType) {
    const weaponPickup = new THREE.Mesh(
        new THREE.SphereGeometry(10),
        new THREE.MeshBasicMaterial({
            color: 0x0000ff,
            side: THREE.DoubleSide
        })
    );
    weaponPickup.position.copy(position);
    weaponPickup.userData.existInGame = true;
    weaponPickup.userData.isEnemyNPC = false;
    weaponPickup.userData.isLight = false;
    weaponPickup.userData.gameObjectType = "WeaponPickup";
    weaponPickup.userData.weaponType = weaponType;

    weaponPickup.name = "Weapon Pickup - " + Math.floor(Math.random() * 1000);
    addToScene(weaponPickup);
    MAPOBJECTS.push(weaponPickup);
    return weaponPickup;
}

const createBox = function(type) {
    const cube = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.MeshBasicMaterial({
            color: new THREE.Color(0xffffff),
            side: THREE.DoubleSide
        })
    );
    switch (type) {
        case "Wall":
            cube.scale.set(64, 64, 2);
            break;
        case "Floor":
            cube.scale.set(64, 2, 64);
            break;
        case "Detail":
            cube.scale.set(2,2,2);
            break;
        default:
            console.error("Invalid Box Type: " + type);
            break;
    }
    const cubePosition = new THREE.Vector3();
    cubePosition.copy(camera.position);
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    cubePosition.add(camDir.multiplyScalar(camera.position.distanceTo(groundFloor.position)));
    if (type == "Detail") {
        // place it right in front of the camera
        cubePosition.copy(camera.position.clone().add(camDir.multiplyScalar(0.1)));
    }
    cubePosition.x = multipleCheck(cubePosition.x, 32);
    cubePosition.y = multipleCheck(cubePosition.y, 32);
    cubePosition.z = multipleCheck(cubePosition.z, 32);
    cube.position.copy(cubePosition);
    shiftUp(cube);

    cube.userData.gameObjectType = type;
    cube.userData.isRotated = false;
    cube.userData.existInGame = true;
    cube.userData.materialType = "smooth";
    cube.userData.isLight = false;
    cube.userData.lightBrightness = 0;
    cube.userData.isCutaway = false;
    cube.userData.isEnemyNPC = false;
    cube.userData.interactionEvent = "none";

    cube.name = type + " - " + Math.floor(Math.random() * 1000);
    realignTexture(cube, cube.scale.x, cube.scale.z);
    addToScene(cube);
    MAPOBJECTS.push(cube);
}

// ### CONTEXT MENU
const rightClickMenu = document.querySelector("#right-click-menu");
const contextMenuClick = function (action) {
    switch (action) {
        //  ### Object Creation
        case "Create Wall":
            createBox("Wall");
            break;
        case "Create Floor/Ceiling":
            createBox("Floor");
            break;
        case "Create Detail Object":
            createBox("Detail");
            break;
        case "Create NPC Enemy":
            // set EnemyNPCPosition to be right IN FRONT of the camera
            const enemyNPCPosition = new THREE.Vector3();
            enemyNPCPosition.copy(camera.position);
            enemyNPCPosition.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(40));

            createEnemyNPC(enemyNPCPosition, 0);
            break;
        case "Create Weapon Pickup":
            const weaponPickupPosition = new THREE.Vector3();
            weaponPickupPosition.copy(camera.position);
            weaponPickupPosition.add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(40));

            createWeaponPickup(weaponPickupPosition, "SMG");
            break;
        //  ### Object Manipulation
        case "Delete Object":
            selectedObjects.forEach(selectedObject => {
                removeFromScene(selectedObject);
            });
            break;
        case "Clone Object":
            selectedObjects.forEach(selectedObject => {
                const clone = selectedObject.clone();
                clone.name = selectedObject.name + " (Clone " + Math.floor(Math.random() * 1000) + ")";
                addToScene(clone);
                MAPOBJECTS.push(clone);
            });
            break;
        default:
            console.log("Unassigned Action! [" + action + "]");
            break;
    }
}
const mouseDownPosition = new THREE.Vector2();
const mouseUpPosition = new THREE.Vector2();
document.addEventListener("mousedown", function (e) { mouseDownPosition.set(e.clientX, e.clientY); });
document.addEventListener("mouseup", function (e) { mouseUpPosition.set(e.clientX, e.clientY); });
const invokeContextMenu = function (e) {
    const clickedElement = document.elementFromPoint(globalMousePosition.clientX, globalMousePosition.clientY);
    const options = [];
    if (clickedElement.id == "left-panel" || clickedElement.id == "editor-canvas") {
        options.push("[] Add Geometry");
        options.push("Create Wall");
        options.push("Create Floor/Ceiling");
        options.push("Create Detail Object");
        options.push("[] Add Entities");
        options.push("Create NPC Enemy");
        options.push("Create Weapon Pickup");
    }
    if (clickedElement.parentElement.id == "scene-objects-list") {
        options.push("Delete Object");
        options.push("Clone Object");
    }
    // if options is empty, return;
    if (options.length == 0) {
        rightClickMenu.style.display = "none";
        return;
    }
    // empty the menu
    rightClickMenu.innerHTML = "";
    for (let i = 0; i < options.length; i++) {
        // if it starts with [], create a <hr> with legend
        if (options[i].startsWith("[]")) {
            const divider = document.createElement("div");
            divider.classList.add("context-menu-divider");
            divider.innerHTML = options[i].replace("[]", "");
            rightClickMenu.appendChild(divider);
            continue;
        }
        const option = document.createElement("li");
        option.innerHTML = options[i];
        rightClickMenu.appendChild(option);
        // add a click event listener
        option.addEventListener("click", function () {
            // handle contextMenuClick with the innerhtml
            contextMenuClick(option.innerHTML);
        });
    }
    rightClickMenu.style.display = "block";
    rightClickMenu.style.animation = "fade-in 0.1s ease-in-out";
    rightClickMenu.style.left = globalMousePosition.clientX + "px";
    rightClickMenu.style.top = globalMousePosition.clientY + "px";
}
document.body.addEventListener("contextmenu", function (e) {
    e.preventDefault();
    // if it's on #editor-canvas, return
    if (e.target.id == "editor-canvas") {
        return;
    }
    invokeContextMenu(e);
});
// on click out
document.body.addEventListener("click", function (e) {
    rightClickMenu.style.display = "none";
});

canvas.addEventListener("click", function (e) {
    if (mouseUpPosition.distanceTo(mouseDownPosition) < 5) {
        // shoot ray until first target is hit, attach transformControls to it
        const raycaster = new THREE.Raycaster();

        var mouse = new THREE.Vector2();

        const rect = renderer.domElement.getBoundingClientRect();
        const x = globalMousePosition.clientX - rect.left;
        const y = globalMousePosition.clientY - rect.top;

        mouse.x = (x / canvas.clientWidth) * 2 - 1;
        mouse.y = (y / canvas.clientHeight) * - 2 + 1

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        let index = 0;
        if (intersects.length > 0) {
            // organize the interects by distance
            intersects.sort(function (a, b) {
                return a.distance - b.distance;
            });
            const disallowedObjects = [
                "TransformControlsGizmo",
                "TransformControlsPlane",
                "CameraHelper",
                "LineSegments",
                "Sprite",
                "human",
                "Line",
            ]
            // remove any intersects that are, have a parent that is, or have a parent whose parent is, any disallowedObjects type
            for (let i = 0; i < intersects.length; i++) {
                if (disallowedObjects.includes(intersects[i].object.type)) {
                    intersects.splice(i, 1);
                    i--;
                }
                else if (intersects[i].object.parent != null && disallowedObjects.includes(intersects[i].object.parent.type)) {
                    intersects.splice(i, 1);
                    i--;
                }
                else if (intersects[i].object.parent != null && intersects[i].object.parent.parent != null && disallowedObjects.includes(intersects[i].object.parent.parent.type)) {
                    intersects.splice(i, 1);
                    i--;
                }
            }
            if (!intersects[index]) {
                clearSelectedObjects();
                updateRightPanel(null, true);
                return;
            }
            attachHandles(intersects[index].object);
            // add "active" to the <li> in left-panel with the object's name, and remove it from all other objects
            const list = document.querySelector("#scene-objects-list");
            for (let i = 0; i < list.children.length; i++) {
                if (list.children[i].innerHTML == intersects[index].object.name) {
                    list.children[i].classList.add("active");
                }
                else {
                    list.children[i].classList.remove("active");
                }
            }
        }
    }
});

// ### EXPORTING ###
// we will save the scene data into a JSON file, excluding any children we dont want

const saveProject = function () {
    console.log("Saving...")
    clearSelectedObjects(); // this will apply all scales outside of selectedObjects group

    const metaData = {};
    metaData.mapMakerSave = [];

    MAPOBJECTS.forEach(mapObject => {
        if (mapObject.isMesh) {
            // save the size, position, color
            metaData.mapMakerSave.push({
                "type": mapObject.userData.gameObjectType,
                "isRotated": mapObject.userData.isRotated,
                "size": {
                    "x": Math.round(mapObject.scale.x), // We round again in case i ever add anything stupid in the future that would cause a decimal (post-typescript change)
                    "y": Math.round(mapObject.scale.y),
                    "z": Math.round(mapObject.scale.z)
                },
                "position": {
                    "x": Math.round(mapObject.position.x),
                    "y": Math.round(mapObject.position.y),
                    "z": Math.round(mapObject.position.z)
                },
                "rotation": {
                    "x": mapObject.rotation.x,
                    "y": mapObject.rotation.y,
                    "z": mapObject.rotation.z
                },
                "material": mapObject.userData.materialType,
                "isCutaway": mapObject.userData.isCutaway,
                "color": {
                    "r": mapObject.material.color.r,
                    "g": mapObject.material.color.g,
                    "b": mapObject.material.color.b
                },
                "isLight": mapObject.userData.isLight,
                "lightBrightness": mapObject.userData.lightBrightness,
                "isEnemyNPC": mapObject.userData.isEnemyNPC,
                "weaponType": mapObject.userData.weaponType,
                "rotationIntervals": mapObject.userData.rotationIntervals,
                "interactionEvent": mapObject.userData.interactionEvent
            });
        }
    });

    metaData.cameraData = {
        "cameraPosition": {
            "x": playerSpawn.position.x,
            "y": playerSpawn.position.y,
            "z": playerSpawn.position.z
        },
        "cameraRotation": {
            "x": playerSpawn.rotation.x,
            "y": playerSpawn.rotation.y,
            "z": playerSpawn.rotation.z
        }
    }

    metaData.ambientColor = {
        "r": ambientColor.r,
        "g": ambientColor.g,
        "b": ambientColor.b
    };

    metaData.nextLevelURL = nextLevelURL;

    var saveData = { voxels: [] }

    var ipc = require('electron').ipcRenderer;
    ipc.send('refresh-save', {
        saveName: 'savedata'
    });

    ipc.on('ready-to-save', (event, arg) => {
        ipc.send('init-new-savefile');
        ipc.send('set-savename', {
            saveName: filePath,
        });
        // SEND CAMERA DATA
        ipc.send('savefile-add-custom-data', {
            dataName: "cameraData",
            data: JSON.stringify(metaData.cameraData)
        });
        // SEND GROUND DATA
        ipc.send('savefile-add-custom-data', {
            dataName: "ambientColor",
            data: JSON.stringify(metaData.ambientColor)
        });
        // SEND NEXT LEVEL URL
        ipc.send('savefile-add-custom-data', {
            dataName: "nextLevelURL",
            data: JSON.stringify(metaData.nextLevelURL)
        });
        // SAVE MAPMAKERSAVE
        ipc.send('savefile-add-custom-data', {
            dataName: "mapMakerSave",
            data: JSON.stringify(metaData.mapMakerSave)
        });
        // END CUSTOM DATA
        // wait 250ms for the file to be written
        setTimeout(() => {
            ipc.send('savefile-end-custom-data');
            console.log("Written Successfully.");
        }, 250);

        console.log("Written Successfully.");
    });

}

document.querySelector("#save-button").addEventListener("click", function () {
    saveProject();
});

const capitalizeFirstLetter = function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

// ### OPENING ###
// we will ask the user for a file, and load it into the scene
const importProject = function () {
    console.log("Importing...")
    // clearSelectedObjects();

    // ask for a file
    var input = document.createElement('input');
    input.type = 'file';
    input.onchange = e => {
        var file = e.target.files[0];
        filePath = file.path;
        console.log(filePath);

        var reader = new FileReader();
        reader.readAsText(file, 'UTF-8');

        reader.onload = readerEvent => {
            var content = readerEvent.target.result;
            const parsedJSON = JSON.parse(content);
            const mapMakerSaveData = parsedJSON.mapMakerSave;
            console.log(mapMakerSaveData);

            mapMakerSaveData.forEach(mapMakerObject => {
                if (mapMakerObject.isEnemyNPC == true)
                {
                    createEnemyNPC(
                        new THREE.Vector3(mapMakerObject.position.x, mapMakerObject.position.y, mapMakerObject.position.z),
                        mapMakerObject.rotationIntervals
                    );
                }
                else if (mapMakerObject.weaponType != undefined) {
                    createWeaponPickup(
                        new THREE.Vector3(mapMakerObject.position.x, mapMakerObject.position.y, mapMakerObject.position.z),
                        mapMakerObject.weaponType
                    );
                }
                else
                {
                    const newBox = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 1, 1),
                        new THREE.MeshBasicMaterial({
                            color: new THREE.Color(mapMakerObject.color.r, mapMakerObject.color.g, mapMakerObject.color.b),
                            map: new THREE.TextureLoader().load('../textures/' + mapMakerObject.material + '.png'),
                            side: THREE.DoubleSide
                        })
                    );
                    newBox.material.side = THREE.DoubleSide;
                    newBox.material.map.magFilter = THREE.NearestFilter;
                    newBox.material.map.wrapS = THREE.RepeatWrapping;
                    newBox.material.map.wrapT = THREE.RepeatWrapping;
                    newBox.name = capitalizeFirstLetter(mapMakerObject.material + " Box ID:" + Math.floor(Math.random() * 1000000));
                    newBox.position.set(mapMakerObject.position.x, mapMakerObject.position.y, mapMakerObject.position.z);

                    newBox.userData.materialType = mapMakerObject.material;
                    newBox.userData.isCutaway = mapMakerObject.isCutaway;
                    if (mapMakerObject.isCutaway) newBox.material = cutawayMaterial;
                    newBox.userData.existInGame = true;
                    newBox.userData.isLight = mapMakerObject.isLight;
                    newBox.userData.lightBrightness = mapMakerObject.lightBrightness;
                    newBox.userData.interactionEvent = mapMakerObject.interactionEvent ? mapMakerObject.interactionEvent : "none";

                    newBox.userData.isRotated = mapMakerObject.isRotated;
                    newBox.userData.gameObjectType = mapMakerObject.type;
                    newBox.userData.isEnemyNPC = mapMakerObject.isEnemyNPC;

                    addToScene(newBox);
                    MAPOBJECTS.push(newBox);
                    newBox.scale.x = mapMakerObject.size.x;
                    newBox.scale.y = mapMakerObject.size.y;
                    newBox.scale.z = mapMakerObject.size.z;
                    realignTexture(newBox, newBox.scale.x, newBox.scale.z);
                }
            })

            document.querySelector("#ambient-color").value = "#" + new THREE.Color(parsedJSON.ambientColor.r, parsedJSON.ambientColor.g, parsedJSON.ambientColor.b).getHexString();
            ambientColor.set(document.querySelector("#ambient-color").value);

            document.querySelector("#next-level-url").value = parsedJSON.nextLevelURL;

            nextLevelURL = parsedJSON.nextLevelURL;


            updateLeftPanel();
            // scene.add(selectedObjects);
            sendTooltip("Map Imported Successfully!");
        }
    }
    input.click();
}

document.querySelector("#import-button").addEventListener("click", function () {
    importProject();
});

    </script>

    <style>
        :root {
            --editor-bg-color: #202020;
            --side-panel-bg-color: #1B1B1B;
            --bottom-panel-bg-color: #171717;
            --font-color: #FFFFFF;
        }

        * {
            margin: 0;
            overflow: hidden;
            color: white;
            font-family: 'Montserrat', sans-serif;
            user-select: none;
        }

        #right-click-menu {
            position: absolute;
            margin: 0;

            background: rgb(40, 39, 42);
            display: none;

            z-index: 2000;
        }

        .context-menu-divider {
            border-top: 1px solid rgb(64, 64, 64);
            color: rgb(106, 106, 106);
            font-weight: bold;
            padding: 5px 10px;
            list-style: none;
        }

        #right-click-menu li {
            color: rgb(137, 135, 135);
            font-weight: bold;
            padding: 5px 15px;
            list-style: none;
        }

        #right-click-menu li:hover {
            background: rgb(64, 64, 64);
            cursor: pointer;
        }

        @keyframes fade-in {
            0% {
                opacity: 0;
            }

            100% {
                opacity: 1;
            }
        }

        /* Style the container */
        .container {
            height: 100%;
            display: grid;
            grid-template-columns: 1fr 3fr 1fr;
            grid-template-rows: 0.4fr 4fr 1.75fr;
            grid-gap: 0px;
            background-color: var(--editor-bg-color);
            padding: 0px;

        }

        /* Universal for all panels */
        .panel {
            padding: 10px;
        }

        /* Style the left panel */
        #left-panel {
            grid-column: 1 / 2;
            grid-row: 2 / 4;
            background-color: var(--side-panel-bg-color);
            overflow-y: scroll !important;
        }

        /* scrollbar */
        #left-panel::-webkit-scrollbar {
            width: 10px;
        }

        #left-panel::-webkit-scrollbar-track {
            background: rgb(40, 40, 40);
        }

        #left-panel::-webkit-scrollbar-thumb {
            background-color: rgb(64, 64, 64);
            border-radius: 20px;
            border: 3px solid rgb(40, 40, 40);
        }

        #left-panel ul {
            margin: 10px 0px;
            padding: 0;
        }

        #left-panel li {
            padding: 10px;
            font-size: 80%;
        }

        #left-panel li:hover {
            background: rgb(64, 64, 64);
            cursor: pointer;
        }

        .active {
            background: rgb(40, 40, 40);
        }

        /* Style the top panel */
        #top-panel {
            padding: 0px;
            grid-column: 1 / 4;
            grid-row: 1 / 2;
            background-color: var(--editor-bg-color);
        }

        /* Style the right panel */
        #right-panel {
            grid-column: 3 / 4;
            grid-row: 4 / 2;
            background-color: var(--side-panel-bg-color);
        }

        /* Style the bottom panel */
        #bottom-panel {
            grid-column: 2 / 3;
            grid-row: 3 / 5;
            background-color: var(--bottom-panel-bg-color);
            resize: vertical;
            transform: rotate(180deg);
            max-height: 500px;
            min-height: 200px;
        }

        /* Style the center panel  */
        #center-panel {
            grid-column: 2 / 3;
            grid-row: 2 / 3;
            background-color: var(--editor-bg-color);

            margin: 0;
            padding: 0;

            /* absolute center all elements inside this */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #top-panel-bar {
            display: table;
            width: 100%;
            height: 100%;
            text-align: center;
        }

        .top-panel-option {
            /* vertical align spans in a div with 100% height */
            display: table-cell;
            vertical-align: middle;
        }

        .nohover:hover {
            background-color: var(--editor-bg-color) !important;
            cursor: default !important;
        }

        .top-panel-option:hover {
            background-color: #2B2B2B;
            cursor: pointer;
        }

        .resize-unflip {
            transform: rotate(180deg);
            height: 100%;
        }

        input,
        select {
            border-radius: 5px;
            padding: 10px;
            margin: 5px;
            border: none;
            background: #303030;
            border-radius: 2px;
            outline: 2px solid #2e2e2e;
            color: var(--font-color);
            padding-top: 5px;
        }

        input[type=color] {
            /* reset */
            padding: 0;
            margin: 0;
            border: none;
            background: none;
            border-radius: 0;
            outline: none;
        }

        button {
            /* dark with light text, slim outline and border radius */
            background: #303030;
            color: var(--font-color);
            border: 1px solid #2e2e2e;
            border-radius: 2px;
            outline: 2px solid #2e2e2e;
        }

        /* number inputs */
        /* dont show arrows */
        input[type=number] {
            max-width: 25%;
            -moz-appearance: textfield;
        }

        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none !important;
            margin: 0 !important;
        }

        
        .tooltip {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 20px 10px;
            background: deepskyblue;
            border: 1px solid lightblue;
            border-radius: 5px;
            animation: slideUp 3s ease-in-out;
            animation-fill-mode: forwards;
        }

        @keyframes slideUp {
            0% {
                opacity: 0;
                transform: translateY(0%);
            }

            25% {
                opacity: 1;
            }

            75% {
                opacity: 1;
                transform: translateY(0%);
            }

            100% {
                opacity: 0;
                transform: translateY(-100px);
            }
        }
    </style>
</body>

</html>