<!DOCTYPE html><html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		* {
			margin: 0;
		}

		body {
			background: black;
			margin: 0;
			overflow: hidden;
			font-family: 'Montserrat', sans-serif;
			user-select: none;
		}

		canvas {
			position: absolute;
			top: 0%;
			left: 0%;
			display: block;
			transform: translate3d(0, 0, 0);
			/* forces hardware acceleration */
		}

		.on-drugs {
			animation: trippin 1.5s cubic-bezier(0.075, 0.82, 0.165, 1) 0ms infinite alternate;
		}

		@keyframes trippin {
			from {filter: hue-rotate(0)}
			to {filter: hue-rotate(360deg)}
		}

		#crosshair-overlay {
			position: absolute;
			top: 50%;
			left: 50%;
			color: lightgreen;
			text-shadow: 0 0 10px white;
			font-size: 150%;
			z-index: 1000;
			transform: translate(-50%, -50%);
		}

		#position-overlay {
			position: absolute;
			top: 0;
			left: 0;
			color: black;
			text-shadow: 0 0 10px white;
			font-size: 150%;
			z-index: 1000;
			padding: 10px;
		}

		#interaction-text {
			/* center */
			position: absolute;
			top: 50%;
			left: 50%;
			color: white;
			text-shadow: 0 0 10px black;
			z-index: 1000;
			transform: translate(-50%, 150%);
			padding: 15px;
			background: rgba(0, 0, 0, 0.85);
			opacity: 0;
		}

		#help-text {
			/* bottom center */
			position: absolute;
			bottom: 0;
			left: 50%;
			color: white;
			text-shadow: 0 0 10px black;
			z-index: 1000;
			padding: 20px;
			transform: translate(-50%, 0);
			opacity: 0.25;
		}

		#loader {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			letter-spacing: -5px;
			font-weight: bold;
			color: rgb(246, 255, 0);
			font-size: 750%;
		}

		#loader-bg {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: black;
			animation-fill-mode: forwards;
			z-index: 2000;
		}

		@keyframes fade-out {
			0% {
				opacity: 1;
			}

			100% {
				opacity: 0;
			}
		}

		@keyframes fade-in {
			0% {
				opacity: 0;
			}

			100% {
				opacity: 1;
			}
		}

		.fade-in {
			animation: fade-in 0.15s forwards;
		}

		@keyframes pop-up {
			0% {
				transform: translate(-50%, 150%);
				opacity: 0;
			}

			100% {
				transform: translate(-50%, -50%);
				opacity: 1;
			}
		}

		.pop-up {
			animation: pop-up 0.75s forwards;
		}

		#popup-window {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			padding: 20px;
			background: rgba(0, 0, 0, 0.85);
			color: white;
			text-shadow: 0 0 10px black;
			z-index: 1000;
			opacity: 0;
			width: 80%;
			height: 80%;
			display: none;
		}

		#vizbox {
			position: absolute;
			bottom: 35px;
			left: 35px;
			z-index: 1000;
			font-size: 12px;
			color: yellow;
			font-weight: bold;
			padding: 10px 30px;
			background: rgba(0, 0, 0, 0.85);
		}

		#DRAWCALLSViz {
			color: lightyellow;
		}

		#XViz {
			color: lightcoral;
		}

		#YViz {
			color: lightgreen;
		}

		#ZViz {
			color: lightblue;
		}

		#NUMVOXELSViz {
			color: lightpink;
		}

		#NUMCOVERBOXESViz {
			color: lightcyan;
		}

		#fullframe {
			width: 100%;
			height: 100%;
			border: none;
		}
	</style>

</head>

<body>
	<!-- LOADER -->
	<div id="loader-bg">
		<div id="loader">LOADING</div>
	</div>

	<!-- DEBUG BOX -->
	<div id="vizbox">
		<div id="FPSViz">Loading ...</div>
		<div id="DRAWCALLSViz">Loading ...</div>
		<div id="NUMVOXELSViz">Loading ...</div>
		<div id="NUMCOVERBOXESViz">Loading ...</div>
		<div id="XViz">N/A</div>
		<div id="YViz">N/A</div>
		<div id="ZViz">N/A</div>
	</div>

	<!-- WEB BROWSER -->
	<div id="popup-window">
		<webview id="fullframe" src="storymode_computer/email/emailHub.html" disablewebsecurity></webview>
		<script>
			// on press of "k" set webview's src to example.com
			document.addEventListener('keydown', (e) => {
				if (e.key === 'k') {
					document.getElementById('fullframe').src = 'https://example.com';
				}
			});
		</script>
	</div>

	<!-- THREE JS IMPORTS -->
	<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
	<script type="importmap">
			{
				"imports": {
					"three": "../opensource/threejs/build/three.module.js",
					"three/addons/": "../opensource/threejs/examples/jsm/",
					"three/nodes": "../opensource/threejs/examples/jsm/nodes/Nodes.js"
				}
			}
	</script>
	<!-- AUDIO ENGINE IMPORT -->
	<script src="../opensource/howler/howler.js"></script>
	<!-- PHYSICS ENGINE IMPORT -->
	<scrit src="../opensource/oimo.min.js"></scrit>
	<!-- INSPECTOR PANEL IMPORT -->
	<script src="../opensource/dat.gui.min.js"></script>
	<!-- STATS.JS -->
	<script>(function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); stats.dom.style.zIndex = 1000; requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = 'https://mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })()</script>
	<!-- DOT CROSSHAIR -->
	<div id="middle-crosshair"
		style="position: absolute; top: 50%; left: 50%; transform: translate(-100%, -100%); width: 2px; height: 2px; background: white; z-index: 1000;">
	</div>

	<div id="interaction-text"></div>
	<div id="help-text">Loading . . .</div>
</body>

<script type="module">

	// ##########
	// MODULE IMPORTS
	// ##########
	// THREE
	import * as THREE from 'three';
	import { mix, range, normalWorld, oscSine, timerLocal } from 'three/nodes';
	// import WebGPU from 'three/addons/capabilities/WebGPU.js';
	// import WebGPURenderer from 'three/addons/renderers/webgpu/WebGPURenderer.js';
	import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
	import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
	import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
	import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
	import { SAOPass } from 'three/addons/postprocessing/SAOPass.js';
	import { N8AOPass } from "../opensource/N8AO.js"
	import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
	import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
	import { ConvexHull } from 'three/addons/math/ConvexHull.js';
	import { LightProbeGenerator } from 'three/addons/lights/LightProbeGenerator.js';
	import { LightProbeHelper } from 'three/addons/helpers/LightProbeHelper.js';
	// WRECKMESH
	import { ParticleMesh, Particle } from './ParticleEngine.js'; // particle system
	import { USERSETTINGS, LevelHandler } from './LevelHandler.js'; // user settings and level info
	import { InputHandler } from './InputHandler.js'; // DOM input
	import { lerp, clamp, rapidFloat, moveTowards } from './EngineMath.js'; // math functions
	import { voxelField, generateDestroyedChunkAt } from './VoxelStructures.js'; // data structures for handling voxels
	import { NPC } from './NPC.js'; // non-player characters (NPCs)
	import { resetGameState } from './GameStateControl.js'; // Level Data
	import { WeaponHandler } from './WeaponHandler.js'; // Weapon Data
	import { setHelpText, setInteractionText, getInteractionText } from './UIHandler.js'; // User Interface
	import { generateWorld, voxelGeometry, voxelMaterial} from './WorldGenerator.js'; // Map Generation
	import { PlayerController } from './PlayerMotionController.js'; // First Person Controller

	// ##########
	// GLOBAL HANDLERS
	// ##########
	const LEVELHANDLER = new LevelHandler(
		new THREE.Scene(),
		new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000)
	);
	const WEAPONHANDLER = LEVELHANDLER.WEAPONHANDLER = new WeaponHandler(LEVELHANDLER)
	const INPUTHANDLER = new InputHandler();
	
	// ##########
	// WORLD SPHERE (BACKDROP COLOR)
	// ##########
	const worldSphere = new THREE.Mesh(
		new THREE.SphereGeometry(5000, 16, 8),
		new THREE.MeshBasicMaterial(
			{
				color: new THREE.Color(0xffffff),
				side: THREE.DoubleSide,
				map: LEVELHANDLER.globalTextureLoader.load("../textures/smooth.png")
			}
		)
	)
	worldSphere.material.map.wrapS = worldSphere.material.map.wrapT = THREE.RepeatWrapping;
	worldSphere.material.map.repeat.set(10, 10);
	LEVELHANDLER.scene.add(worldSphere);

	// ##########
	// RENDERER SETUP
	// ##########
	// Initializes the THREE.js renderer
	LEVELHANDLER.renderer.powerPreference = "high-performance";
	LEVELHANDLER.renderer.debug.checkShaderErrors = false;
	LEVELHANDLER.renderer.toneMapping = THREE.ACESFilmicToneMapping // currently bugged out? (r152 see bug report from 2021 going back a few versions, im not smart enough to understand how to fix it... color math is so beyond me)
	LEVELHANDLER.renderer.outputEncoding = THREE.sRGBEncoding;
	LEVELHANDLER.renderer.outputColorSpace = THREE.SRGBColorSpace;
	LEVELHANDLER.renderer.info.autoReset = false;
	LEVELHANDLER.renderer.logarithmicDepthBuffer = true;
	LEVELHANDLER.renderer.setSize(window.innerWidth, window.innerHeight);
	LEVELHANDLER.renderer.setPixelRatio(window.devicePixelRatio);
	document.body.appendChild(LEVELHANDLER.renderer.domElement);
	LEVELHANDLER.renderer.domElement.style.zIndex = "-1";
	LEVELHANDLER.renderer.shadowMap.enabled = false
	LEVELHANDLER.renderer.setClearColor(0xffffff)
	THREE.ColorManagement.enabled = true;
	THREE.ColorManagement.legacyMode = false;

	// ##########
	// ENVIRONMENT LIGHTING SETUP
	// ##########
	const lightProbe = new THREE.LightProbe();
	LEVELHANDLER.scene.add(lightProbe);
	const cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256 );
	const cubeCamera = new THREE.CubeCamera( 1, 1000, cubeRenderTarget );
	console.log(cubeRenderTarget.texture);
	// LEVELHANDLER.scene.add( new LightProbeHelper( lightProbe, 5 ) );
	// const cubemap = new THREE.CubeTextureLoader().load(
	// 	[
	// 		'../opensource/cherry_skybox/left.png',
	// 		'../opensource/cherry_skybox/right.png',
	// 		'../opensource/cherry_skybox/up.png',
	// 		'../opensource/cherry_skybox/down.png',
	// 		'../opensource/cherry_skybox/front.png',
	// 		'../opensource/cherry_skybox/back.png',
	// 	]
	// )
	// LEVELHANDLER.background = cubemap;

	// ##########
	// POST PROCESSING
	// ##########
	const composer = new EffectComposer(LEVELHANDLER.renderer);
	const n8aopass = new N8AOPass(LEVELHANDLER.scene, LEVELHANDLER.camera, window.innerWidth, window.innerHeight);
	n8aopass.setQualityMode("Ultra");
	n8aopass.configuration.intensity = 4;
	n8aopass.configuration.radius = 64;
	n8aopass.configuration.halfRes = true;
	n8aopass.configuration.gammaCorrection = false;
	composer.addPass(n8aopass);
	const bloomPass = new UnrealBloomPass(new THREE.Vector2(8, 8), 0.8, 0, 0.45);
	composer.addPass(bloomPass);

	// What the hell is this?? I fucking hate javascript.
	// Hours of research and there is no way around this awful bundling system
	// The most popular language in the world feels like its in its infancy
	// what shitholes designed this??
	// ^ note from the future: i dont remembe why i wrote this or why i was so angry. the code it references seems to be missing now.

	// ##########
	// DEFAULT AMBIENT LIGHTING
	// ##########
	// Initializes the THREE.js lighting
	const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
	LEVELHANDLER.scene.add(ambientLight);

	// ##########
	// DOM CONTROLS (POINTERLOCKAPI)
	// ##########
	const controls = new PointerLockControls(LEVELHANDLER.camera, LEVELHANDLER.renderer.domElement);
	LEVELHANDLER.scene.add(controls.getObject());
	LEVELHANDLER.renderer.domElement.addEventListener('mousedown', () => lockControls());

	// ##########
	// FILESYSTEM CONSTANTS
	// ##########
	// These mark locations in the local file system that store the map and current weapon
	const modelURL = 'savedata';
	const weaponURL = '../weapons/' + 'smg/smg';
	WEAPONHANDLER.generateWeaponModel(weaponURL); // same as map, but for the weapon!
	const interactableObjects = [];
	// This stores every individual displaced voxel that is currently being simulated.
	// TODO: Add gc to this, dead voxels still exist in the array. This will lead to memory problems in big maps.
	const destroyedVoxels = [];

	// This starts building the map ...
	// It attempts to load the JSON file, and allows quick transformations to the file (if needed / between versions) before calling buildWorldModel(), which actually builds the instanceMeshes
	// (Only one map can be loaded at once... unless?)
	// TODO - origin offsets for multiple map loading?
	//  ^ this is very unncessary but could be useful for features like streaming
	generateWorld(modelURL, LEVELHANDLER, USERSETTINGS, worldSphere);

	// ##########
	// PARTICLE ENGINE INITIALIZATION
	// ##########
	const particleHandler = new ParticleMesh(voxelGeometry, voxelMaterial, USERSETTINGS.particleQualityMode * 100);
	LEVELHANDLER.scene.add(particleHandler);
	particleHandler.frustumCulled = false;

	const clock = new THREE.Clock();
	const raycaster = new THREE.Raycaster();

	const updateDebugViz = function(delta) {
		document.querySelector("#FPSViz").textContent = Math.round(1 / delta) + " fps";
		document.querySelector("#DRAWCALLSViz").textContent = LEVELHANDLER.renderer.info.render.calls + " calls (~ " + parseInt(LEVELHANDLER.potentialCleanCalls) + " clean)";
		let numVoxels = LEVELHANDLER.numVoxels;
		numVoxels = numVoxels.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
		document.querySelector("#NUMVOXELSViz").textContent = numVoxels + " voxels";
		document.querySelector("#NUMCOVERBOXESViz").textContent = LEVELHANDLER.numCoverBoxes + " covers";
		document.querySelector("#XViz").textContent = "X: " + Math.round(LEVELHANDLER.camera.position.x);
		document.querySelector("#YViz").textContent = "Y: " + Math.round(LEVELHANDLER.camera.position.y);
		document.querySelector("#ZViz").textContent = "Z: " + Math.round(LEVELHANDLER.camera.position.z);
	}

	const playerController = new PlayerController(controls, LEVELHANDLER, USERSETTINGS, INPUTHANDLER, WEAPONHANDLER);

	let frameCounter = 0;
	// ### RENDER LOOP ###
	const render = function () {
		// Frame Calculations
		frameCounter = (frameCounter + 1) % 60;
		const delta = clock.getDelta() * LEVELHANDLER.timeModifier;
		// Debug Visualizer
		updateDebugViz(delta);
		// Update Active NPC's
		LEVELHANDLER.NPCBank.forEach( npc => npc.update(delta) );
		// Update Active Particles
		particleHandler.update(delta);
		// Update Skybox Attributes
		worldSphere.position.copy(LEVELHANDLER.camera.position);
		worldSphere.material.map.center.set(worldSphere.material.map.center.x + (delta/100), worldSphere.material.map.center.y + (delta/1000));
		// Player Movement Handling
		playerController.update(delta);

		let targetFOV = USERSETTINGS.baseFOV;
		if (INPUTHANDLER.isRightClicking) {
			targetFOV = USERSETTINGS.baseFOV - 20;
			switch (WEAPONHANDLER.weaponType) {
				case undefined:
					break;
				default:
					console.error("Illegal Weapon Type - \"" + WEAPONHANDLER.weaponType + "\"");
					break;
				case "melee":
				case "ranged":
					WEAPONHANDLER.weaponTarget.position.set(WEAPONHANDLER.adsPosition.x, WEAPONHANDLER.adsPosition.y, WEAPONHANDLER.adsPosition.z);
					WEAPONHANDLER.weaponTarget.rotation.set(WEAPONHANDLER.adsRotation.x, WEAPONHANDLER.adsRotation.y, WEAPONHANDLER.adsRotation.z);
			}
		}
		else {
			if (WEAPONHANDLER.weaponTarget) WEAPONHANDLER.weaponTarget.position.set(WEAPONHANDLER.weaponPosition.x, WEAPONHANDLER.weaponPosition.y, WEAPONHANDLER.weaponPosition.z);
		}
		LEVELHANDLER.camera.fov = lerp(LEVELHANDLER.camera.fov, targetFOV, 10 * delta);
		if (Math.abs(LEVELHANDLER.camera.fov - targetFOV) > 1) LEVELHANDLER.camera.updateProjectionMatrix();

		if (INPUTHANDLER.isLeftClicking) {
			switch (WEAPONHANDLER.weaponType) {
				case undefined:
					break;
				default:
					console.error("Illegal Weapon Type - \"" + WEAPONHANDLER.weaponType + "\"");
					break;
				case "melee":
					// move weaponModel position forward relative to player LEVELDATA.camera
					if (WEAPONHANDLER.isAttackAvailable) WEAPONHANDLER.weaponModel.translateX(50);
				case "ranged":
					if (WEAPONHANDLER.weaponRemainingAmmo > 0)
					{
						if (WEAPONHANDLER.isAttackAvailable) {
							WEAPONHANDLER.weaponRemainingAmmo--;
							if (!INPUTHANDLER.isRightClicking) {
								const weaponShakeIntensity = 2.5;
								WEAPONHANDLER.weaponTarget.position.set(
									WEAPONHANDLER.weaponPosition.x + rapidFloat() * weaponShakeIntensity - weaponShakeIntensity / 2 - 0.5,
									WEAPONHANDLER.weaponPosition.y + rapidFloat() * weaponShakeIntensity - weaponShakeIntensity / 2 + 0.5,
									WEAPONHANDLER.weaponPosition.z + rapidFloat() * weaponShakeIntensity - weaponShakeIntensity / 2 + 0.5
								);
							}

							// Play Sound
							LEVELHANDLER.SFXPlayer.playSound("shootSound");

							// GOD i HATE javascript
							// type annotations? NO.
							// parameter delcarations? NO.
							// return types? NO.
							// why don't i just kill myself now?
							shootRay();

							raycaster.far = WEAPONHANDLER.weaponRange;
							raycaster.setFromCamera(new THREE.Vector2(0, 0), LEVELHANDLER.camera);
							const intersects = raycaster.intersectObjects(LEVELHANDLER.NPCBank.map(npc => npc.sceneObject.children[0]));

							for (let i = 0; i < intersects.length; i++) {
								const mainObj = intersects[i].object;
								if (mainObj.npcHandler.health > 0) {
									// Register Hit
									mainObj.npcHandler.depleteHealth(WEAPONHANDLER.weaponDamage);
								}
								// Squelch!
								LEVELHANDLER.SFXPlayer.playSound("hitSound");
								// TODO - create a shoot effect
							}

							WEAPONHANDLER.isAttackAvailable = false;
							setTimeout(function () {
								WEAPONHANDLER.isAttackAvailable = true;
							}, WEAPONHANDLER.fireRate);
						}
					}
					break;
				case "explosive":
					if (WEAPONHANDLER.isAttackAvailable) {

						plantExplosive();

						WEAPONHANDLER.isAttackAvailable = false;
						setTimeout(function () {
							WEAPONHANDLER.isAttackAvailable = true;
						}, WEAPONHANDLER.fireRate);
					}
					break;
			}
		}

		if (INPUTHANDLER.isKeyPressed("e")) {
			LEVELHANDLER.playerHeight += 0.5;
			// WEAPONHANDLER.throwWeapon(voxelField);
		}
		if (INPUTHANDLER.isKeyPressed("q")) {
			LEVELHANDLER.playerHeight -= 0.5;
		}

		// DEBUG PANEL (in console)
		if (INPUTHANDLER.isKeyPressed("p")) {
			console.log("\n+==============================+\n")
			console.log("CAMERA POSITION");
			console.log(LEVELHANDLER.camera.position);
			console.log("draw calls #");
			console.log(LEVELHANDLER.renderer.info.render.calls);
			console.log("THREE SCENE");
			console.log(LEVELHANDLER.scene);
			console.log("\n+==============================+\n")
		}

		// Raycasting for interactables
		if (frameCounter % 10 == 0) {
			raycaster.far = 100;
			raycaster.setFromCamera(new THREE.Vector2(0, 0), LEVELHANDLER.camera);
			const intersects = raycaster.intersectObjects(interactableObjects);
			if (intersects.length > 0) {
				if (getInteractionText().innerHTML != intersects[0].object.interactionEvent) setInteractionText(intersects[0].object.interactionEvent);
			}
			else {
				if (getInteractionText().innerHTML != "") setInteractionText("");
			}
		}

		requestAnimationFrame(render);

		LEVELHANDLER.renderer.info.reset();
		composer.render();
	}

	const createVizSphere = function (position, size=2) {
		const sphere = new THREE.Mesh(
			new THREE.SphereGeometry(size,2,2),
			new THREE.MeshBasicMaterial({ color: new THREE.Color(0xffffff * rapidFloat()), transparent: true, opacity: 0.5 })
		);
		sphere.position.copy(position);
		LEVELHANDLER.scene.add(sphere);
	}

	const cubeSprite = LEVELHANDLER.globalTextureLoader.load("../img/cubesprite.png");
	const conjunctionCheckTimesPerSecond = 1;
	const recentlyEditedWorldModels = [];
	const maxChunksInPhysicsCache = 15;
	const conjunctionCheck = function () {

		const holeBorder = [];

		// CONJUNCTION CHECK
		recentlyEditedWorldModels.forEach(instancedModel => {
			const deadVoxels = instancedModel.deadVoxels;
			for (let i = 0; i < deadVoxels.length; i++) {
				const thisVector = new THREE.Vector3(
					deadVoxels[i][0],
					deadVoxels[i][1],
					deadVoxels[i][2]
				);
				const voxel = voxelField.get(thisVector.x, thisVector.y, thisVector.z);
				if (voxel != null && voxel.value == 0) {
					holeBorder.push(thisVector);
				}
			}
			// recentlyEditedWorldModels.splice(recentlyEditedWorldModels.indexOf(instancedModel), 1);
		});

		// if all voxels in the holeSet touch each other, then they are a hole.
		const startTime = performance.now();
		const confirmedTouch = [];
		holeBorder.forEach(holeA => {
			const holeApos = new THREE.Vector3(holeA.x, holeA.y, holeA.z);
			holeBorder.forEach(holeB => {
				const holeBpos = new THREE.Vector3(holeB.x, holeB.y, holeB.z);
				if (holeApos.distanceTo(holeBpos) < 2) {
					// if it isnt in the confirmedTouch array, add it
					if (!confirmedTouch.includes(holeA)) {
						confirmedTouch.push(holeA);
					}
				}
			});
		});

		const fullHole = [];
		if (confirmedTouch.length == holeBorder.length) {
			const maxPositions = [];
			const minPositions = [];
			const clearedYPositions = []; // store Y positions that have at LEAST two X,Z positions
			for (let i = 1; i < holeBorder.length; i++) {
				// min positions for EVERY Y LEVEL
				if (minPositions[holeBorder[i].y] == undefined) {
					minPositions[holeBorder[i].y] = holeBorder[i];
				}
				else {
					if (holeBorder[i].x < minPositions[holeBorder[i].y].x) {
						minPositions[holeBorder[i].y] = holeBorder[i];
					}
					if (holeBorder[i].z < minPositions[holeBorder[i].y].z) {
						minPositions[holeBorder[i].y] = holeBorder[i];
					}
				}
				// max positions for EVERY Y LEVEL
				if (maxPositions[holeBorder[i].y] == undefined) {
					maxPositions[holeBorder[i].y] = holeBorder[i];
				}
				else {
					if (holeBorder[i].x > maxPositions[holeBorder[i].y].x) {
						maxPositions[holeBorder[i].y] = holeBorder[i];
					}
					if (holeBorder[i].z > maxPositions[holeBorder[i].y].z) {
						maxPositions[holeBorder[i].y] = holeBorder[i];
					}
				}
			}
			const hasAYPosition = function (x, z) {
				let count = 0;
				for (let i = 0; i < holeBorder.length; i++) {
					if (holeBorder[i].x == x && holeBorder[i].z == z) count++;
					if (count >= 2) return true;
				}
				return false;
			}
			for (let i = 1; i < minPositions.length; i++) {
				const minPos = minPositions[i];
				const maxPos = maxPositions[i];
				if (minPos == undefined || maxPos == undefined) continue;
				// if clearedYpositions does NOT include this Y position, or its length is less than 2, then skip it
				// for every voxel beween min and max, add it to the fullHole array
				for (let x = minPos.x; x <= maxPos.x; x++) {
					for (let z = minPos.z; z <= maxPos.z; z++) {
						const voxel = voxelField.get(x, i, z);
						if (!hasAYPosition(x, z)) continue;
						if (voxel.value == 1) {
							voxelField.set(x, i, z, 2, voxel.indexInChunk, voxel.chunk);
							voxel.chunk.setMatrixAt(voxel.indexInChunk, new THREE.Matrix4());
							voxel.chunk.instanceMatrix.needsUpdate = true;

							voxel.position = new THREE.Vector3(x, i, z);
							voxel.color = voxelField.get(x, i, z).color;

							fullHole.push(voxel);
						}
					}
				}
			}
			const endTime = performance.now();
			console.log("conjunction check took " + (endTime - startTime) + " milliseconds");

			if (fullHole.length > 5) {
				LEVELHANDLER.SFXPlayer.playRandomSound("bigDropSounds");
			}
			
			// fullhole = array of voxels that are in the hole, and need to be removed
		}
	}

	document.addEventListener('mousedown', function (e) {
		// if mouse4 click
		if (e.button == 3) {
			conjunctionCheck();
			activateExplosives();
		}
	});

	const lockControls = function() {
		controls.lock();
		document.querySelector("#popup-window").style.display = "none";
	}

	const shootRay = function () {
		// RAYCAST INTO THE VOXEL FIELD
		// STEP 1: GET THE CAMERA POSITION
		// STEP 2: GET THE CAMERA DIRECTION
		// STEP 3: CALL voxelField.raycast() WITH THE CAMERA POSITION AND DIRECTION, and a step range of weaponRange
		// STEP 4: IF THE RAYCAST RETURNS A HIT, DESTROY THE VOXEL AT THAT POSITION
		// CAMERA POSITION
		const cameraPosition = new THREE.Vector3();
		LEVELHANDLER.camera.getWorldPosition(cameraPosition);
		cameraPosition.x = Math.round(cameraPosition.x);
		cameraPosition.y = Math.round(cameraPosition.y);
		cameraPosition.z = Math.round(cameraPosition.z);
		const cameraDirection = new THREE.Vector3();
		LEVELHANDLER.camera.getWorldDirection(cameraDirection);
		const intersection = voxelField.raycast(cameraPosition, cameraDirection, WEAPONHANDLER.weaponRange);
		// Determine which voxels in chunk are to be destroyed
		if (intersection != null) {
			// get the lowest lod model for this voxel
			const currentModel = intersection.chunk;

			// disable any attached light
			if (currentModel.attachedLight != undefined) // TODO: this check may be unnecessary
			{
				currentModel.attachedLight.visible = false;
			}

			// build a list of each destroyed voxel
			let destroyedVoxelsInChunk = [];

			// the position at which we hit
			const intersectPosition = new THREE.Vector3(
				intersection.x,
				intersection.y,
				intersection.z
			)

			const intersectedVoxelData = voxelField.get(intersectPosition.x, intersectPosition.y, intersectPosition.z);

			// for every voxel within a WEAPONHANDLER.destroyedChunkRange of the intersection, destroy it
			for (let x = intersectPosition.x - WEAPONHANDLER.destroyedChunkRange; x <= intersectPosition.x + WEAPONHANDLER.destroyedChunkRange; x++) {
				for (let y = intersectPosition.y - WEAPONHANDLER.destroyedChunkRange; y <= intersectPosition.y + WEAPONHANDLER.destroyedChunkRange; y++) {
					for (let z = intersectPosition.z - WEAPONHANDLER.destroyedChunkRange; z <= intersectPosition.z + WEAPONHANDLER.destroyedChunkRange; z++) {
						if (rapidFloat() < 0.9)
						{
							destroyedVoxelsInChunk.push(new THREE.Vector3(
								x,
								y,
								z
							));
						}
					}
				}
			}

			// 
			// ### ASSIGN PHYSICS
			// 
			// if recentlyeditedworldmodels DOES NOT HAVE currentmodel
			if (!recentlyEditedWorldModels.some(model => model.name == currentModel.name)) {
				recentlyEditedWorldModels.push(currentModel);
			}
			if (recentlyEditedWorldModels.length > maxChunksInPhysicsCache) recentlyEditedWorldModels.shift();
			generateDestroyedChunkAt(destroyedVoxelsInChunk, USERSETTINGS, LEVELHANDLER, particleHandler);
		}
	}

	render(); // calls render loop

	// window resize handler
	window.addEventListener('resize', () => {
		const width = window.innerWidth;
		const height = window.innerHeight;
		console.log("Handling resize ->", width, height)
		LEVELHANDLER.renderer.setSize(width, height);
		composer.setSize(width, height);
		LEVELHANDLER.camera.aspect = width / height;
		LEVELHANDLER.camera.updateProjectionMatrix();
	}, false);

	setHelpText("Loading Map...");
</script>

</html>